Module 4 - Completion - Module Test

1. Which one of the following lines properly starts a parameterless function definition?
- [ ] `fun function():`
- [ ] `def fun:`
- [ ] `def fun():`
- [ ] `function fun():`

<details>
  <summary>Check</summary>

  - Answer: `def fun():`
  - Reason: The correct way to declare a function in Python is to use the reserved keyword **def** followed by the name of the function, **parentheses ()** and a colon ':'. Since it is parameterless, the parentheses are empty.
</details>

2. A function defined in the following way:  (Select **two** answers)

```python
def function(x=0):
    return x

```

- [ ] must be invoked without any argument
- [ ] may be invoked without any argument
- [ ] must be invoked with exactly one argument
- [ ] may be invoked with exactly one argument

<details>
  <summary>Check</summary>

  - Answers: `may be invoked without any argument` and NOT `must be invoked with exactly one argument`
  - Reason: The function has a predefined value for the parameter _x_; therefore it can be invoked with or without it. However, more than one argument will generate a runtime error.
</details>

3. A built-in function is a function which:
- [ ] comes with Python, and is an integral part of Python
- [ ] has to be imported before use
- [ ] is hidden from programmers
- [ ] has been placed within your code by another programmer

<details>
  <summary>Answer</summary>

  - Answer: `comes with Python, and is an integral part of Python`
  - Reason: Built-in functions are integrated in Python. Once Python is installed, they are available and can be used.
</details>

4. The fact that tuples belong to sequence types means that:
- [ ] they are actually lists
- [ ] they can be indexed and sliced like lists
- [ ] they can be extended using the `.append()` method
- [ ] they can be modified using the `del` instruction

<details>
  <summary>Answer</summary>

  - Answer: `they can be indexed and sliced like lists`
  - Reason: Tuples are **immutable objects**, so they can be indexed and sliced like lists. However, during runtime they cannot be extended or modified. They are NOT lists.
</details>

5. What is the output of the following snippet?

```python
def f(x):
    if x == 0:
        return 0
    return x + f(x - 1)


print(f(3))

```

- [ ] `1`
- [ ] the code is erroneous
- [ ] `6`
- [ ] `3`

<details>
  <summary>Answer</summary>

  - Answer: `6`
  - Reason:
    Let's analyze the code:

    - the _f_ function is invoked with an integer argument of 3,
    - the function begins its execution with an integer value of 3 for the _x_ variable.
    - the _if_ conditional compares 3 == 0, and since it is false, it is not executed,
    - the function reaches the return statement, and an integer value of 3 is held in the memory, plus a recursive invocation of the _f_ function with an integer argument of 2,
    - the _if_ conditional compares 2 == 0, and since it is false, it is not executed,
    - the function reaches the return statement, and an integer value of 2 is held in the memory ,plus a recursive invocation of the _f_ function with an integer argument of 1,
    - the _if_ conditional compares 1 == 0, and since it is false, it is not executed,
    - the function reaches the return statement, and an integer value of 1 is held in the memory, plus a recursive invocation of the _f_ function with an integer argument of 0,
    - the _if_ conditional compares 0 == 0, and since it is true, the return statement 0 is executed and the recursive invocation is broken,
    - Each recursive invocation returns its value and the addition is printed on the console, which is 6.
</details>

6. What is the output of the following snippet?

```python
def fun(x):
    x += 1
    return x


x = 2
x = fun(x + 1)
print(x)

```

- [ ] `5`
- [ ] the code is erroneous
- [ ] `4`
- [ ] `3`

<details>
  <summary>Answer</summary>

  - Answer: `4`
  - Reason: Let's analyze the code:
    - the _x_ variable is assigned an integer value of _2_,
    - the _fun_ function is invoked with an argument of (_2+1_), and the result will be assigned to the _x_ variable,
    - the execution of the fun function begins, which receives _3_, and then increments it by _1_, and returns _4_,
    - the _x_ variable receives the integer value of _4_,
    - the variable _x_ is printed on the console.
</details>

7. What code would you insert instead of the comment to obtain the expected output?

Expected output:
```
a
b
c
```

Code:
```python
dictionary = {}
my_list = ['a', 'b', 'c', 'd']

for i in range(len(my_list) - 1):
    dictionary[my_list[i]] = (my_list[i], )

for i in sorted(dictionary.keys()):
    k = dictionary[i]
    # Insert your code here.

```

- [ ] `print(k['0'])`
- [ ] `print(k[0])`
- [ ] `print(k)`
- [ ] `print(k["0"])`

<details>
  <summary>Answer</summary>

  - Answer: `print(k[0])` ?
  - Reason: Let's analyze the code:
	- an empty _dictionary_ is created,
	- a list named _my_list_ with the elements ['a', 'b', 'c', 'd'] is created,
	- a _for_ loop in the range of the list length minus one (0 to 3) is initialized, and the values that the _i_ variable iterates are a,b,c,d,
	- for each iteration, a key-pair value will be inserted in the dictionary. The key is a String, and the value is a tuple with one element,
	- the resulting dictionary is: {'a': ('a',), 'b': ('b',), 'c': ('c',)}
	- another _for_ loop is initialized, and the _i_ variable iterates the sorted dictionary keys,
	- the _k_ variable stores the value for each key,
	- since it is a tuple, it is necessary to select the print(k[0]) option in order to print the first and only element.
</details>

8. The following snippet:

```python
def func(a, b):
    return a ** a


print(func(2))

```

- [ ] will output `4`
- [ ] will return `None`
- [ ] will output `2`
- [ ] is erroneous

<details>
  <summary>Answer</summary>

  - Answer: `is erroneous`
  - Reason: The code snippet is erroneous because the function is invoked with one argument, but two are needed, since both parameters don't have a predefined value.
</details>

9. The following snippet:

```python
def func_1(a):
    return a ** a


def func_2(a):
    return func_1(a) * func_1(a)


print(func_2(2))

```

- [ ] will output `4`
- [ ] is erroneous
- [ ] will output `16`
- [ ] will output `2`

<details>
  <summary>Answer</summary>

  - Answer: <code>will output `16`</code>
  - Reason: Let's analyze the code:
	- the _func_2_ function is invoked with the integer 2 as its argument,
	- the _func_2_ function returns the product of _func_1(2) * func_1(2)_
	- _the func_1_ function is invoked twice with an integer argument of 2,
	- _the func_1_ function returns 2*2, which is 4,
	- the _func_2_ function returns the product of _4 * 4, which is 16_,
	- the result is printed on the console.
</details>

10. Which of the following lines properly starts a function using two parameters, both with zeroed default values?
- [ ] `def fun(a=b=0):`
- [ ] `def fun(a=0, b=0):`
- [ ] `fun fun(a=0, b):`
- [ ] `fun fun(a, b=0):`

<details>
  <summary>Answer</summary>

  - Answer: `def fun(a=0, b=0):`
  - Reason: The correct way to define parameters with default values is to state the name of the variable, the assignment sign (=), and the default value, e.g. a=0. If there are more default values, separate them with commas.
</details>

11. Which of the following statements are true? (Select two answers)
- [ ] The `None` value cannot be used outside functions
- [ ] The `None` value can be used as an argument of arithmetic operators
- [ ] The `None` value can be compared with variables
- [ ] The `None` value can be assigned to variables

<details>
  <summary>Answer</summary>

  - Answers: <code>The `None` value can be assigned to variables</code> and <code>The `None` value can be compared with variables</code>
  - Reason: The None value can be assigned to any variable, inside and outside of functions. It can also be used in conditionals and loops. However, it cannot be used in arithmetic operations.
</details>

12. What is the output of the following snippet?

```python
def fun(x):
    if x % 2 == 0:
        return 1
    else:
        return


print(fun(fun(2)) + 1)

```

- [ ] `1`
- [ ] `None`
- [ ] the code will cause a runtime error
- [ ] `2`

<details>
  <summary>Answer</summary>

  - Answer: `the code will cause a runtime error`
  - Reason: Let's analyze the code:
	- the inner parentheses in the print function are executed first,
	- the _fun_ function is invoked with the integer _2_ as an argument,
	- the if conditional _2 % 2 == 0_ returns **True**, so the _fun_ function returns _1_,
	- the _fun_ function is invoked with the integer 1 as its argument,
	- the if conditional _1 % 2 == 0_ returns **False**, so the _fun_ function returns _None_,
	- The arithmetic operation _None + 1_ is attempted,
	- A runtime error is generated: _TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'_.
</details>

13. What is the output of the following snippet?

```python
def fun(x):
    global y
    y = x * x
    return y


fun(2)
print(y)

```

- [ ] `None`
- [ ] `4`
- [ ] `2`
- [ ] the code will cause a runtime error

<details>
  <summary>Answer</summary>

  - Answer: `4`
  - Reason: Let's analyze the code:
	- the _fun_ function is invoked with the integer _2_ as its argument,
	- the _fun_ function makes the _y_ variable a global variable, which can be used both inside and outside of the function,
	- the operation _y = 2 * 2_ is performed, and the answer is the integer _4_,
	- the function returns the _y_ variable value,
	- the print(y) instruction prints the integer _4_ on the console.
</details>

14. What is the output of the following snippet?

```python
def any():
    print(var + 1, end='')


var = 1
any()
print(var)

```

- [ ] `21`
- [ ] `22`
- [ ] `11`
- [ ] `12`

<details>
  <summary>Answer</summary>

  - Answer: `21`
  - Reason: Let's analyze the code:
	- the _var_ variable is assigned the integer 1 as its value,
	- the _any&_ function is invoked, and it executes the arithmetic operation 1+1 and prints the result **2** on the console. The instruction _end=''_ prevents a newline jump,
	- the instruction print(var) prints **1** on the console.
</details>

15. Assuming that `my_tuple` is a correctly created tuple, the fact that tuples are immutable means that the following instruction:

`my_tuple[1] = my_tuple[1] + my_tuple[0]` 

- [ ] is illegal
- [ ] can be executed if and only if the tuple contains at least two elements
- [ ] is fully correct
- [ ] may be illegal if the tuple contains strings

<details>
  <summary>Answer</summary>

  - Answer: `is illegal`
  - Reason: The operation is illegal because the 'tuple' object does not support item assignment.
</details>

16. What is the output of the following snippet?

```python
my_list =  ['Mary', 'had', 'a', 'little', 'lamb']


def my_list(my_list):
    del my_list[3]
    my_list[3] = 'ram'


print(my_list(my_list))

```

- [ ] `['Mary', 'had', 'a', 'lamb']`
- [ ] no output, the snippet is erroneous
- [ ] `['Mary', 'had', 'a', 'little', 'lamb']`
- [ ] `['Mary', 'had', 'a', 'ram']`

<details>
  <summary>Answer</summary>

  - Answer: no output, the snippet is erroneous
  - Reason: Let's analyze the code:
	- a list named _my_list_ is created,
	- a function named _my_list_ is created,
	- the _print_ function tries to invoke the _my_list_ function using the list _my_list_ as an argument. However, the list _my_list_ no longer exists because the function has the same name, and the function replaces the list,
	- the code will end in a runtime error because the function does not support item deletion.
</details>

17. What is the output of the following snippet?

```python
def fun(x, y, z):
    return x + 2 * y + 3 * z


print(fun(0, z=1, y=3))

```

- [ ] the snippet is erroneous
- [ ] `0`
- [ ] `9`
- [ ] `3`

<details>
  <summary>Answer</summary>

  - Answer: `9`
  - Reason: Let's analyze the code:
	- the _fun_ function is invoked, and the arguments take these values: x = 0, y = 3, z = 1. Remember that positional arguments should be placed before keyword arguments,
	- the _fun_ function returns the result of the following arithmetic operation: 0 + 2 * 3 + 3 * 1,
	- the products are carried out first: 0 + 6 + 3,
	- the addition is performed, and the result is 9,
	- the print function shows 9 in the console.
</details>

18. What is the output of the following snippet?

```python
def fun(inp=2, out=3):
    return inp * out


print(fun(out=2))

```

- [ ] the snippet is erroneous
- [ ] `4`
- [ ] `6`
- [ ] `2`

<details>
  <summary>Answer</summary>

  - Answer: `4`
  - Reason: Let's analyze the code:
	- the _fun_ function is invoked, and the argument used is _out = 2_, which replaces the predefined value of _out = 3_,
	- the _fun_ function takes the predefined value of _inp = 2_, since it is not defined in the invocation of the function,
	- the _fun_ function performs the operation 2*2 and returns it,
	- the print function shows 4 on the console.
</details>

19. What is the output of the following code?

```python
dictionary = {'one': 'two', 'three': 'one', 'two': 'three'}
v = dictionary['one']

for k in range(len(dictionary)):
    v = dictionary[v]

print(v)

```

- [ ] `two`
- [ ] `('one', 'two', 'three')`
- [ ] `one`
- [ ] `three`

<details>
  <summary>Answer</summary>

  - Answer: `two`
  - Reason: Let's analyze the code:
	- the following _dictionary_ is defined: dictionary = {'one': 'two', 'three': 'one', 'two': 'three'}
	- the _v_ variable stores the value for key 'one', which is 'two',
	- a _for_ loop is initialized in the range of the dictionary's length. It will iterate 3 times,
	- in the first iteration, the _v_ variable will store the value for key 'two', which is 'three',
	- in the second iteration, the _v_ variable will store the value for key 'three', which is 'one',
	- in the third iteration, the _v_ variable will store the value for key 'one', which is 'two',
	- the for loop is exited and the print function shows 'two' on the console.
</details>

20. What is the output of the following code?

```python
tup = (1, 2, 4, 8)
tup = tup[1:-1]
tup = tup[0]
print(tup)

```

- [ ] `(2, )`
- [ ] the snippet is erroneous
- [ ] `2`
- [ ] `(2)`

<details>
  <summary>Answer</summary>

  - Answer: `2`
  - Reason: Let's analyze the code:
	- a tuple named _tup_ with the following elements is defined: (1, 2, 4, 8)
	- the tuple _tup_is replaced with a shorter version of itself. The indices are [1:-1], which means it will start at position 1 to the second-last element of the tuple. The new tuple is (2, 4)
	- the tuple _tup_ is again replaced with its first element only: tup[0], and the result is no longer a tuple,
	- the print function shows 2 on the console.
</details>

21. Select the **true** statements about the _try-except_ block in relation to the following example. (Select **two** answers.)

```python
try:
    # Some code is here...
except:
    # Some code is here...

```

- [ ] If there is a syntax error in code located in the `try` block, the `except` branch will **not** handle it, and a _SyntaxError_ exception will be raised instead.
- [ ] If you suspect that a snippet may raise an exception, you should place it in the `try` block.
- [ ] The code that follows the `except` statement will be executed if the code in the `try` clause runs into an error.
- [ ] The code that follows the `try` statement will be executed if the code in the `except` clause runs into an error.

<details>
  <summary>Answer</summary>

  - Answer: <code>If you suspect that a snippet may raise an exception, you should place it in the `try` block.</code> and <code>The code that follows the `except` statement will be executed if the code in the `try` clause runs into an error.</code>
  - Reason: If the code placed inside a _try_ block raises an exception, the following code lines within the block will not be executed, and the exceptions defined below will try to handle the error generated.
</details>

22. What is the output of the following code?

```python
try:
    value = input("Enter a value: ")
    print(value/value)
except ValueError:
    print("Bad input...")
except ZeroDivisionError:
    print("Very bad input...")
except TypeError:
    print("Very very bad input...")
except:
    print("Booo!")

```

- [ ] `Booo!`
- [ ] `Very bad input...`
- [ ] `Very very bad input...`
- [ ] `Bad input...`

<details>
  <summary>Answer</summary>

  - Answer: `Very very bad input...`
  - Reason: Let's analyze the code:
	- the _value_ variable will store whatever the user inputs as a string,
	- the print function will try to divide the value by itself,
	- since strings cannot be divided, a _TypeError_ exception is raised,
	- the exception _TypeError_ will be compared sequentially with the defined exceptions,
	- when it reaches _except TypeError_, the print function will show _Very very bad input..._ on the console.

</details>
