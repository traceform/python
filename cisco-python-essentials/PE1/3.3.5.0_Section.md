3.3.5 How do we deal with single bits?

We'll now show you what you can use bitwise operators for. Imagine that you're a developer obliged to write an important piece of an operating system. You've been told that you're allowed to use a variable assigned in the following way:

```
flag_register =Â 0x1234Â 
```

The variable stores the information about various aspects of system operation.Â **Each bit of the variable stores one yes/no value**. You've also been told that only one of these bits is yours â€’ the third (remember that bits are numbered from zero, and bit number zero is the lowest one, while the highest is number 31). The remaining bits are not allowed to change, because they're intended to store other data. Here's your bit marked with the letterÂ `x`:

```
flag_register = 0000000000000000000000000000x000Â 
```

You may be faced with the following tasks:

1.Â **Check the state of your bit**Â â€’ you want to find out the value of your bit; comparing the whole variable to zero will not do anything, because the remaining bits can have completely unpredictable values, but you can use the following conjunction property:

```
x &Â 1Â = x
x &Â 0Â =Â 0
```

If you apply theÂ `&`Â operation to theÂ `flag_register`Â variable along with the following bit image:

```
00000000000000000000000000001000
```

(note theÂ `1`Â at your bit's position) as the result, you obtain one of the following bit strings:

- `00000000000000000000000000001000`Â if your bit was set toÂ `1`
- `00000000000000000000000000000000`Â if your bit was reset toÂ `0`

Such a sequence of zeros and ones, whose task is to grab the value or to change the selected bits, is called aÂ **bit mask**.

Let's build a bit mask to detect the state of your bit. It should point toÂ **the third bit**. That bit has the weight ofÂ `2Â³ = 8`. A suitable mask could be created by the following declaration:

```
the_mask =Â 8
```

You can also make a sequence of instructions depending on the state of your bit. Here it is:

```
if flag_register & the_mask:
    # My bit is set.
else:
    # My bit is reset.

```

2.Â **Reset your bit**Â â€’ you assign a zero to the bit while all the other bits must remain unchanged; let's use the same property of the conjunction as before, but let's use a slightly different mask â€’ exactly as below:

```
11111111111111111111111111110111Â 
```

Note that the mask was created as a result of the negation of all the bits ofÂ `the_mask`Â variable. Resetting the bit is simple, and looks like this (choose the one you like more):

```
flag_register = flag_register & ~the_mask
flag_register &= ~the_mask

```

3.Â **Set your bit**Â â€’ you assign aÂ `1`Â to your bit, while all the remaining bits must remain unchanged; use the following disjunction property:

```
x | 1 = 1
x | 0 = x

```

You're now ready to set your bit with one of the following instructions:

```
flag_register = flag_register | the_mask
flag_register |= the_mask

```

4.Â **Negate your bit**Â â€’ you replace aÂ `1`Â with aÂ `0`Â and aÂ `0`Â with aÂ `1`. You can use an interesting property of theÂ `xor`Â operator:

```
x ^ 1 = ~x
x ^ 0 = x

```

and negate your bit with the following instructions:

```
flag_register = flag_register ^ the_mask
flag_register ^= the_mask

```

---

Excellent question â€” and one that often confuses beginners because Python doesnâ€™t have a special _â€œbinary typeâ€_. But it does have **integers that can be written in binary form**.

Letâ€™s go step by step. ğŸ‘‡

---

## ğŸ§  1ï¸âƒ£ Storing binary values in variables

You can assign a **binary literal** to a variable using the prefix `0b` (zero + letter â€œbâ€):

```python
x = 0b1010
```

That means:

```
binary 1010 â†’ decimal 10
```

âœ… You can use it just like any integer:

```python
print(x)          # 10
print(bin(x))     # 0b1010  (shows binary representation)
```

---

## ğŸ§® 2ï¸âƒ£ Converting between forms

|Conversion|Example|Result|
|---|---|---|
|**Binary â†’ Decimal**|`int('1010', 2)`|10|
|**Decimal â†’ Binary**|`bin(10)`|`'0b1010'`|
|**Binary literal assignment**|`x = 0b1010`|`x == 10`|

---

## ğŸ§© 3ï¸âƒ£ Example

```python
# store binary directly
a = 0b1101      # 13 in decimal
b = 0b0101      # 5 in decimal

# bitwise operations
print(a & b)    # 5 (0b0101)
print(a | b)    # 13 (0b1101)
print(a ^ b)    # 8 (0b1000)

# print them in binary format
print(bin(a & b))  # 0b101
```

---

## ğŸ§° 4ï¸âƒ£ You can also use **bit shifts** for building masks

This is the cleanest way to â€œstore a single bit positionâ€:

```python
bit_3 = 1 << 3   # 0b1000 â†’ 8 in decimal
```

This means â€œthe bit in position 3 is on.â€

---

## âš™ï¸ 5ï¸âƒ£ Storing multiple bits (flags)

You can combine bits using `|`:

```python
READ  = 0b0001
WRITE = 0b0010
EXEC  = 0b0100

permissions = READ | WRITE
print(bin(permissions))  # 0b11
```

Then check them:

```python
if permissions & READ:
    print("Read allowed")
```

---

## âš ï¸ Common pitfall

If you write:

```python
x = "0b1010"
```

thatâ€™s **a string**, not binary.  
Youâ€™d have to convert it:

```python
x = int("0b1010", 2)  # â†’ 10
```

---

### âœ… Summary

|Method|Description|Example|
|---|---|---|
|Binary literal|Easiest way|`x = 0b1010`|
|Convert string|From input or text|`int('1010', 2)`|
|Display binary|See binary form|`bin(10)`|
|Bit shift|Build bit masks|`1 << 3`|
