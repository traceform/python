Final Test

1. What is the output of the following snippet?

```python
my_list = [1, 2]

for v in range(2):
    my_list.insert(-1, my_list[v])

print(my_list)

```

- [ ] `[1, 2, 2, 2]`
- [ ] `[2, 1, 1, 2]`
- [ ] `[1, 2, 1, 2]`
- [ ] `[1, 1, 1, 2]`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: Let’s analyze the program:
	- Line 1: the _my_list_ list is created. The list stores the following contents: _[1, 2]_
	- Line 3: the _range()_ function generates a sequence of two numbers (_0_ and _1_), and the _for_ loop iterates over that sequence. The _v_ variable takes the value of the number inside the sequence on each iteration, and the loop continues until the last number in the sequence is reached. The body of the loop is entered and the `my_list.insert(-1, my_list[v])` operation is performed two times.
	- Line 4: after the first _for_ loop iteration (when _v = 0_), the _[1, 2]_ list is updated – the _insert()_ method inserts a new element to the list (_v = 0_, so _my_list[v] = 1_) at the specified index (-1). The _my_list_ list after the first _for_ loop iteration has the following contents: _[1, 1, 2]_. After the second for loop iteration (when _v = 1_), the _[1, 2, 3]_ list is updated for the second time – the _insert()_ method inserts another new element to the list (_v = 1_, so _my_list[v] = 1_) at the specified index (_-1_). The _my_list_ list after the second _for_ loop iteration contains the following contents: _[1, 1, 1, 2]_.
	- Line 6: the _print()_ function prints the list contents to the screen.
</details>

---

2. The meaning of a _positional argument_ is determined by:
- [ ] its position within the argument list
- [ ] its value
- [ ] its connection with existing variables
- [ ] the argument’s name specified along with its value

<details>
  <summary>Answer</summary>

  - Answer: its position within the argument list
  - Reason: Positional arguments can be called by their position in a function call, and therefore must be included in the correct order.
</details>

---

3. Which of the following sentences are **true** about the code? (Select **two** answers)

```python
nums = [1, 2, 3]
vals = nums

```

- [ ] `nums` and `vals` are different names of the same list
- [ ] `nums` has the same length as `vals`
- [ ] `vals` is longer than `nums`
- [ ] `nums` and `vals` are different lists

<details>
  <summary>Answers</summary>

  - Answers: `nums` and `vals` are different names of the same list AND `nums` has the same length as `vals`
  - Reason: Assigning _nums_ to _vals_ creates a situation in which the same list (i.e. _[1, 2, 3]_) has two different names. Giving a new name to an existing list, in our case _vals_ to nums, is called **aliasing**. And since _nums_ and _vals_ are two different names that refer to the same object, they also have the same length (_3_).
</details>

---

4. An operator able to check whether two values are **not equal** is coded as:
- [ ] `<>`
- [ ] `!=`
- [ ] `not ==`
- [ ] `=/=`

<details>
  <summary>Answer</summary>

  - Answer: `!=`
  - Reason: The _!=_ operator checks whether two values are not equal. For example, the following expression _1 != 2_ will evaluate as _True_.
</details>

---

5. The following snippet:

```python
def function_1(a):
    return None


def function_2(a):
    return function_1(a) * function_1(a)


print(function_2(2))

```

- [ ] will output `16`
- [ ] will cause a runtime error
- [ ] will output `4`
- [ ] will output `2`

<details>
  <summary>Answer</summary>

  - Answer: will cause a runtime error
  - Reason: The _None_ object has no arithmetic operators defined – the program will raise the _TypeError_ exception, because the _NoneType_ type cannot be the _*_ operator’s operand.
</details>

---

6. The result of the following division:

`1 // 2`

- [ ] is equal to `0.0`
- [ ] cannot be predicted
- [ ] is equal to `0`
- [ ] is equal to `0.5`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: The _//_ operator divides two numbers and rounds the result down to the nearest integer number. Since _1_ divided by _2_ is 0.5, the resulting number is rounded down to _0_.
</details>

---

7. The following snippet:

```python
def func(a, b):
    return b ** a


print(func(b=2, 2))

```

- [ ] will output 2
- [ ] will output 4
- [ ] is erroneous
- [ ] will output None

<details>
  <summary>Answer</summary>

  - Answer: is erroneous
  - Reason: The program will raise the _SyntaxError_, because the positional argument in the function call (_2_) follows the keyword argument (_b=2_). Changing the order of the arguments in the _func()_ function invocation (i.e. _func(2, b=2)_) fixes the issue, in which case the program would output _4_ as the result.
</details>

---

8. What value will be assigned to the `x` variable?

```python
z = 0
y = 10
x = y < z and z > y or y < z and z < y

```

- [ ] `1`
- [ ] `True`
- [ ] `0`
- [ ] `False`

<details>
  <summary>Answer</summary>

  - Answer: `False`
  - Reason: Let’s analyze the example:
	- _0_ is assigned to _z_, and _10_ is assigned to _y_,
	- the result of the following evaluation `y < z and z > y or y < z and z < y` is assigned to _x_:
	- _y < z_ evaluates to False,
	- _z > y_ evaluates to False,
	- _y < z_ evaluates to False again,
	- and _z < y_ evaluates to True.
	- And now: False **and** False is False; False **or** False is False; and finally False **and** True is False.
</details>

---

9. Which of the following variable names are **illegal** and will cause the SyntaxError exception? (Select **two** answers)

- [ ] `In`
- [ ] `for`
- [ ] `print`
- [ ] `in`

<details>
  <summary>Answer</summary>

  - Answer: `for` AND ìn`
  - Reason: The _in_ and _for_ names are Python reserved words (keywords). These cannot be used as variable names. Note that the name _print_ is not a Python reserved word and can be used as a variable name, in which case it will shadow the Python built-in function, _print()_.
</details>

---

10. What is the output of the following snippet?

```python
my_list =  [x * x for x in range(5)]


def fun(lst):
    del lst[lst[2]]
    return lst


print(fun(my_list))

```

- [ ] `[0, 1, 4, 9]`
- [ ] `[0, 1, 9, 16]`
- [ ] `[1, 4, 9, 16]`
- [ ] `[0, 1, 4, 16]`

<details>
  <summary>Answer</summary>

  - Answer: `[0, 1, 4, 9]`
  - Reason: Let’s analyze the example:
	- Line 1: The list comprehension is used to create the following list: _[0, 1, 4, 9, 16]_, and assign it to the _my_list_ variable,
	- Lines 4-6: The _fun()_ function is defined, which takes a list (_lst_) as its argument. In the body of the function, the _del_ instruction deletes a specified element of the list, and returns the updated list,
	- Line 9: The _print()_ function takes the _fun()_ function as its argument, and prints the returned value to the screen. The _fun()_ function takes the _my_list_ list as its argument and processes it – the _del_ instruction deletes the fourth element of the list (_my_list[2]_ is _4_).
</details>

---

11. What is the output of the following piece of code?

```python
x = 1
y = 2
x, y, z = x, x, y
z, y, z = x, y, z

print(x, y, z)

```

- [ ] `1 2 1`
- [ ] `1 1 2`
- [ ] `1 2 2`
- [ ] `2 1 2`

<details>
  <summary>Answer</summary>

  - Answer: `1 1 2`
  - Reason: Let’s analyze the example:
	- _x = 1_ and _y = 2_
	- as a result of the first multiple variable assignment (Line 3), **_x = 1_**, _y = 1_, and _z = 2_
	- as a result of the second multiple variable assignment (Line 4), _z = x = 1_, **_y = y = 1_**, and **_z = z = 2_** (because the original assignment from the previous line now overwrites the first _z_ assignment from the current line)
	- the result printed to the screen is therefore `1 1 2`
</details>

---

12. What will be the output of the following snippet?

```python
a = 1
b = 0
a = a ^ b
b = a ^ b
a = a ^ b

print(a, b)

```

- [ ] `0 0`
- [ ] `0 1`
- [ ] `1 0`
- [ ] `1 1`

<details>
  <summary>Answer</summary>

  - Answer: `0 1`
  - Reason: Let’s analyze the code line by line:
	- Line 1: _1_ is assigned to variable _a_
	- Line 2: _0_ is assigned to variable _b_
	- Line 3: the result of the evaluation is _1_, so _a = 1_
	- Line 4: the result of the evaluation is also _1_, so _b = 1_
	- Line 5: the result of the evaluation _a = a ^ b_ (where _a = 1_ and _b = 1_) is _0_, so _a = 0_
	- the new values assigned to the _a_ and _b_ variables are then printed to the console.
</details>

---

13. What is the output of the following snippet?

```python
def fun(x):
    if x % 2 == 0:
        return 1
    else:
        return 2


print(fun(fun(2)))

```

- [ ] `2None`
- [ ] `1`
- [ ] the code will cause a runtime error
- [ ] `2`

<details>
  <summary>Answer</summary>

  - Answer: `2`
  - Reason: The _print()_ function in line 8 takes the _fun()_ function as its argument, which takes another _fun()_ function as its argument, which in turn takes the value _2_ as its argument.
	
	Let’s analyze the function calls, starting with the right-most ones:
	
	- the _fun(2)_ call – _x_ is assigned the value of _2_, so _x % 2 = 0_, so the comparison _0 == 0_ evaluates to True, and the function returns _1_, which is passed to the “left” _fun()_ function as its argument,
	- the _fun(1)_ call – _x_ is assigned the value of _1_, so _x % 2 = 1_, so the comparison _1 == 0_ evaluates to False, which means the function returns _2_, which is passed to the _print()_ function as its argument. Therefore, _2_ is printed to the screen.
</details>

---

14. Take a look at the snippet and choose the **true** statement:

```python
nums = [1, 2, 3]
vals = nums
del vals[:]

```

- [ ] the snippet will cause a runtime error
- [ ] `nums` and `vals` have the same length
- [ ] `vals` is longer than `nums`
- [ ] `nums` is longer than `vals`

<details>
  <summary>Answer</summary>

  - Answer: `nums` and `vals` have the same length
  - Reason: Assigning _nums_ to _vals_ creates a situation in which the same list (i.e. _[1, 2, 3]_) has two different names. Giving a new name to an existing list, in our case _vals_ to nums, is called **aliasing**. And since _nums_ and _vals_ are two different names that refer to the same object, they are also the same length.

	The _del_ instruction empties the list pointed to by _nums_ and _vals_, which means the list has a zero length, which in turn means that _nums_ and _vals_ are the same length.
</details>

---

15. What is the output of the following piece of code if the user enters two lines containing `3` and `2` respectively?

```python
x = int(input())
y = int(input())
x = x % y
x = x % y
y = y % x
print(y)

```

- [ ] `1`
- [ ] `2`
- [ ] `3`
- [ ] `0`

<details>
  <summary>Answer</summary>

  - Answer: `0`
  - Reason: Let’s analyze what happens:
	- _x = 3_ and _y = 2_
	- Line 3: _x = 3 % 2 = 1_
	- Line 4: _x = 1 % 2 = 1_
	- Line 5: _x = 2 % 1 = **0**_
	- the result is printed to the screen.
</details>

---

16. What is the output of the following piece of code if the user enters two lines containing `3` and `6` respectively?

```python
y = input()
x = input()
print(x + y)

```

- [ ] `36`
- [ ] `6`
- [ ] `3`
- [ ] `63`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: It’s a tricky question because of two reasons:
	- Reason one: the _input()_ function converts the data inputted by the user to a string, and the result of adding two strings to each other is gluing them together: _"string" + "string" = "stringstring"_ (concatenation).
	- Reason two: the first user input is assigned to the _y_ variable, while the second to the _x_variable. However, they are printed in the reverse order.
</details>

---

17. What is the output of the following piece of code?

`print("a", "b", "c", sep="sep")` 

- [ ] `asepbsepcsep`
- [ ] `a b c`
- [ ] `abc`
- [ ] `asepbsepc`

<details>
  <summary>Answer</summary>

  - Answer: `asepbsepc`
  - Reason: The _print()_ function prints the strings _"a"_, _"b"_, and _"c"_ to the screen, and separates them with the "sep" string. The _sep_ keyword parameter determines the type of separator used between the subsequent _print()_ arguments outputted to the screen.
</details>

---

18. What is the output of the following piece of code?

```python
x = 1 // 5 + 1 / 5
print(x)

```

- [ ] `0`
- [ ] `0.5`
- [ ] `0.4`
- [ ] `0.2`
<details>
  <summary>Answer</summary>

  - Answer: `0.2`
  - Reason: Remember the principle of Operator Precedence, and the difference between the two Python division operators: // (integer division) and _/_ (floating-point division). Let’s analyze the expression in the first line:

	Because the division operators have a higher priority than the addition operator, we can add brackets for readability, and evaluate the expression in the following way: _(1 // 5) + (1 / 5)_ gives _0 + 0.2_, which in turn evaluates to _0.2_.
</details>

---

19. Assuming that `my_tuple` is a correctly created tuple, the fact that tuples are immutable means that the following instruction:

`my_tuple[1] = my_tuple[1] + my_tuple[0]` 

- [ ] may be illegal if the tuple contains strings
- [ ] is illegal
- [ ] is fully correct
- [ ] can be executed if and only if the tuple contains at least two elements

<details>
  <summary>Answer</summary>

  - Answer: is illegal
  - Reason: Tuples are immutable sequences, which means you cannot update them directly – adding, changing, or removing tuple items requires different types of operations to be performed, for example converting the tuple to a list, updating the list, and converting it back to a tuple.
</details>

---

20. What is the output of the following piece of code if the user enters two lines containing `2` and `4` respectively?

```python
x = float(input())
y = float(input())
print(y ** (1 / x))

```

- [ ] `1.0`
- [ ] `0.0`
- [ ] `2.0`
- [ ] `4.2`

<details>
  <summary>Answer</summary>

  - Answer: `2.0`
  - Reason: Let’s analyze what happens:
	- the user enters _2_, which is converted to a float, and assigned to the _x_ variable
	- the user enters _4_, which is converted to a float, and assigned to the _y_ variable
	- the result of the following evaluation is printed to the screen: _4 ** (1 / 2) = 4 ** 0.5 = 2.0_
</details>

---

21. What is the output of the following snippet?

```python
dct = {'one': 'two', 'three': 'one', 'two': 'three'}
v = dct['three']

for k in range(len(dct)):
    v = dct[v]

print(v)

```

- [ ] `('one', 'two', 'three')`
- [ ] `two`
- [ ] `one`
- [ ] `three`

<details>
  <summary>Answer</summary>

  - Answer: `one`
  - Reason: Let’s analyze the code:
	- Line 1: the _dct_ dictionary containing three key:value pairs is created
	- Line 2: the _v_ variable is created and assigned the dictionary value associated with the _'three'_ key, that is the string _"one"_
	- Lines 4-5: the _for_ loop performs three iterations (the length of the _dct_ ctionary is _3_):
	- after _k = 0_ _v = "two"_
	- after _k = 1_ _v = "three"_
	- after _k = 2_ _v = "one"_
	- the string "one" assigned to the _v_ variable is then printed to the screen.
</details>

---

22. How many elements does the `lst` list contain?

`lst = [i for i in range(-1, -2)]` 

- [ ] `one`
- [ ] `zero`
- [ ] `two`
- [ ] `three`

<details>
  <summary>Answer</summary>

  - Answer: `zero`
  - Reason: The _lst_ list is empty, because the _range()_ function, which consists in of the list comprehension, sets the _start_ parameter with the initial value of _-1_ and the _stop_ parameter with the initial value of _-2_ (the _stop_ parameter has a lower value than the _start_ parameter, which makes it impossible to create a sequence).
</details>

---

23. Which of the following lines **correctly** invoke the function defined below? (Select **two** answers)

```python
def fun(a, b, c=0):
    # Body of the function.

```

- [ ] `fun(0, 1, 2)`
- [ ] `fun(b=0, a=0)`
- [ ] `fun(b=1)`
- [ ] `fun()`

<details>
  <summary>Answer</summary>

  - Answers: `fun(0, 1, 2)` AND `fun(b=0, a=0)`
  - Reason: Because the _c_ argument is a keyword argument with a specified default value, it’s enough to call the function by specifying default values for the remaining two keyword arguments, _a_ and _b_. It’s also possible to replace a keyword parameter default value with a function call with positional arguments: _fun(0, 1, 2)_. In both cases, it’s important that all the function parameters be served.

	The _fun(b=1)_ call is incorrect because it does not specify a value for the _a_ argument required in the function definition. The _fun()_ call is incorrect because it does not specify the values for the _a_ and _b_ arguments required in the function definition.
</details>

---

24. What is the output of the following snippet?

```python
def fun(x, y):
    if x == y:
        return x
    else:
        return fun(x, y-1)


print(fun(0, 3))

```

- [ ] `1`
- [ ] the snippet will cause a runtime error
- [ ] `2`
- [ ] `0`

<details>
  <summary>Answer</summary>

  - Answer: `0`
  - Reason: The following snippet is an example of a recursive function.

	The following two arguments are sent to the _fun(x, y)_ function: _0_ and _3_. The result of the comparison _x == y_ is False, so the _else:_ block is triggered.

	In the _else:_ block, the _fun(x, y-1)_ function call is returned, and this time the following two arguments are sent: _x = 0_, and _y = 3 - 1 = **2**_. The process is repeated (_x = 0_, _y = 2 – 1 = 1_, and _x = 0_, _y = 1 – 1 = 0) until the value assigned to the _y_ variable is equal to _0_, in which case the result of the _x == y_comparison is True, and the function returns the _x_ value of _0_._
</details>

---

25. How many stars (`*`) will the following snippet send to the console?

```python
i = 0
while i < i + 2 :
    i += 1
    print("*")
else:
    print("*")

```

- [ ] one
- [ ] two
- [ ] the snippet will enter an infinite loop, printing one star per line
- [ ] zero

<details>
  <summary>Answer</summary>

  - Answer: the snippet will enter an infinite loop, printing one star per line
  - Reason: Because _i = 0_, the result of the following comparison: _i < 1 +2_ is True, so the program enters the _while_ loop. However, in the body of the loop _i_ is then incremented, not decremented, which means the result of the comparison _i < 1 +2_ will always evaluate to True, which means the loop will perform an infinite number of iterations, executing the _print("*")_ function with each and every iteration.
</details>

---

26. What is the output of the following snippet?

```python
tup = (1, 2, 4, 8)
tup = tup[-2:-1]
tup = tup[-1]
print(tup)

```

- [ ] `4`
- [ ] `(4,)`
- [ ] `44`
- [ ] `(4)`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: Let’s analyze the code line by line:
	- Line 1: the four-element _tup_ tuple is created
	- Line 2: tuples can be sliced, so the following slice result is assigned to _tup_: _(4,)_
	- Line 3: since the _tup_ tuple is a one-element tuple now _(4,)_, indexing the last and only element will “extract” it from the tuple, and assign to the _tup_ variable as an integer value.
	- the value _4_ will then be printed to the screen.
</details>

---

27. What is the output of the following snippet?

```python
dd = {"1": "0", "0": "1"}
for x in dd.vals():
    print(x, end="")

```

- [ ] `1 0`
- [ ] `0 0`
- [ ] the code is erroneous (the dict object has no vals() method)
- [ ] `0 1`

<details>
  <summary>Answer</summary>

  - Answer: the code is erroneous (the dict object has no vals() method)
  - Reason: The following snippet will raise the _AttributeError_ exception, because the _dict_ object has no attribute named _vals_. Replacing _vals_ with _values_ should do the job.
</details>

---

28. What is the output of the following snippet?

```python
dct = {}
dct['1'] = (1, 2)
dct['2'] = (2, 1)

for x in dct.keys():
    print(dct[x][1], end="")

```

- [ ] `21`
- [ ] `(2,1)`
- [ ] `(1,2)`
- [ ] `12`

<details>
  <summary>Answer</summary>

  - Answer: `21`
  - Reason: Let’s analyze the code:
	- Line 1: an empty dictionary is created
	- Line 2-3: the key:value pairs are created, and added to the _dct_ dictionary:  
	    _dct = {'1': (1, 2), '2': (2, 1)}_
	- Line 5-6: perform two _for_ loop iterations (iterate through the _dct_ keys) and print the dictionary values (tuple elements) indexed in the _print()_ function: _x = 1_ _2_, _x = 2_ _1_
	- the _end=""_ parameter joins the two printed lines together.
</details>

---

29. What is the output of the following snippet?

```python
def fun(inp=2, out=3):
    return inp * out


print(fun(out=2))

```

- [ ] `6`
- [ ] `4`
- [ ] the snippet is erroneous and will cause SyntaxError
- [ ] `2`

<details>
  <summary>Answer</summary>

  - Answer: `4`
  - Reason: The default value (_3_) assigned to the _out_ argument of the _fun()_ function definition has been changed to _2_ in the _fun()_ function call passed as the argument to the _print()_ function. This way the result of the evaluation _(inp = 2) * (out = 2)_ is equal to 4.
</details>

---

30. How many hashes (`#`) will the following snippet send to the console?

```python
lst = [[x for x in range(3)] for y in range(3)]

for r in range(3):
    for c in range(3):
        if lst[r][c] % 2 != 0:
            print("#")

```

- [ ] three
- [ ] nine
- [ ] six
- [ ] zero

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: Let’s analyze the code:
	- Line 1: we’re using a list comprehension to create the following two-dimensional array:  
	    `[[0, 1, 2], [0, 1, 2], [0, 1, 2]]`
	- the program enters the first _for_ loop with the _r_ iteration variable taking the value of the first item inside the sequence generated by the _range(3)_ function, which is _0_. Then the program enters the second (nested) _for_ loop with the _c_ iteration variable taking the value of the first item inside the sequence generated by the _range(3)_ function, which is _0_. The following condition is checked:  
	    `if lst[0][0] % 2 != 0`, then print a hash (#) to the screen. The value returned from the _lst_ list stored under the _[0][0]_ indexes is _0_, so the condition evaluates to false (_0 % 2 != 0_ → _False_), which means a hash is not printed to the screen at this time, and the program execution jumps back to the outer loop. The iterations are repeated for the following index pairs: _[0][1]_, _[0][2]_, _[1][2]_, _[1][0]_, _[1][1]_, _[1][2]_, _[2][2]_, _[2][0]_, _[2][1]_, and _[2][2]_.
	- the _print()_ function will print a hash when the following index pairs become part of the conditional check:
	- _[0][1]_ → _1_ because _if 1 % 2 != 0_ evaluates to True
	- _[1][1]_ → _1_ because _if 1 % 2 != 0_ evaluates to True
	- _[2][1]_ → _1_ because _if 1 % 2 != 0_ evaluates to True
	- Therefore, the _print()_ function will output three hashes to the screen.
</details>

---

31. What is the output of the following code if the user enters a `0`?

```python
try:
    value = input("Enter a value: ")
    print(int(value)/len(value))
except ValueError:
    print("Bad input...")
except ZeroDivisionError:
    print("Very bad input...")
except TypeError:
    print("Very very bad input...")
except:
    print("Booo!")

```

- [ ] `Booo!`
- [ ] `1.0`
- [ ] `0.0`
- [ ] `Very very bad input...`
- [ ] `Bad input...`
- [ ] `Very bad input...`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: The program will print _0.0_ because the following expression _int(0) / len("0")_ evaluates to _0.0_ (_0 / 1_ → _0.0_), so the program flow does not enter any of the _except_ branches, and no exception is raised.
</details>

---

32. What is the expected behavior of the following program?

```python
try:
    print(5/0)
    break
except:
    print("Sorry, something went wrong...")
except (ValueError, ZeroDivisionError):
    print("Too bad...")

```

- [ ] The program will cause a `SyntaxError` exception.
- [ ] The program will cause a `ValueError` exception and output a default error message.
- [ ] The program will raise an exception handled by the first `except` block.
- [ ] The program will cause a `ZeroDivisionError` exception and output the following message: `Too bad...`
- [ ] The program will cause a `ValueError` exception and output the following message: `Too bad...`
- [ ] The program will cause a `ZeroDivisionError` exception and output a default error message.

<details>
  <summary>Answer</summary>

  - Answer: The program will cause a `SyntaxError` exception.
  - Reason: The program will raise a _SyntaxError_ exception, because the _break_ statement used in the _try_ block violates Python’s grammar rules (the _break_ instruction must be used in a loop). When the code is run, before it is executed, the Python interpreter first parses it and converts it to Python byte code. If the parser encounters a syntax error which has a fatal effect on the program, it won’t be able to parse the code successfully, and will raise a _SyntaxError_.

	Remember that the parser analyzes the program before its execution, so if it encounters a syntax error, the program will not be executed. If your code has no syntax errors, the program is executed and may raise other types of exceptions.
</details>

---

33. What is the expected behavior of the following program?

```python
foo = (1, 2, 3)
foo.index(0)

```

- [ ] The program will cause an `AttributeError` exception.
- [ ] The program will cause a `ValueError` exception.
- [ ] The program will cause a `TypeError` exception.
- [ ] The program will cause a `SyntaxError` exception.
- [ ] The program will output `1` to the screen.

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: The program will raise a _ValueError_ exception, because the tuple _index()_ method returns the index of a given element in a tuple, and the _foo_ tuple does not have the _0_ element.

	Full error message: _ValueError: tuple.index(x): x not in tuple_.
</details>

---

34. Which of the following snippets shows the correct way of handling multiple exceptions in a single _except_ clause?

```python
# A:
except (TypeError, ValueError, ZeroDivisionError):
    # Some code.

# B:
except TypeError, ValueError, ZeroDivisionError:
    # Some code.

# C:
except: (TypeError, ValueError, ZeroDivisionError)
    # Some code.

# D:
except: TypeError, ValueError, ZeroDivisionError
    # Some code.

# E:
except (TypeError, ValueError, ZeroDivisionError)
    # Some code.

# F:
except TypeError, ValueError, ZeroDivisionError
    # Some code.

```

- [ ] A only
- [ ] A and B
- [ ] B and C
- [ ] D and E
- [ ] F only
- [ ] A, C, and D
- [ ] A and F


<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: The following syntax:  
  
	`except (TypeError, ValueError, ZeroDivisionError):`  
  
	is the only correct option for handling multiple built-in exceptions within a single _except_ clause.
</details>

---

35. What will happen when you attempt to run the following code?

`print(Hello, World!)`

- [ ] The code will raise the _TypeError_ exception.
- [ ] The code will raise the _AttributeError_ exception.
- [ ] The code will raise the _SyntaxError_ exception.
- [ ] The code will print `Hello, World!` to the console.
- [ ] The code will raise the _ValueError_ exception.

<details>
  <summary>Answer</summary>

  - Answer: The code will raise the _SyntaxError_ exception.
  - Reason: The code will raise a _SyntaxError_ exception, because the string argument passed to the _print()_ function must be delimited by quotes.

	The program does not raise a _NameError_ exception, because the name _World!_ contains an illegal character: !, and _Hello_ and _World!_ cannot be considered variable names that have not been recognized by Python.
</details>