### Index
###### 1. [[#Intro to Programming]]
###### 2. [[#Python is]]
###### 3. [[#Best practices]]
###### 4. [[#Python Built-In Data Types]]
###### 5. [[#Python Keywords]]
###### 6. [[#Operators by priority]]
###### 8. [[#Functions]]
###### 9. [[#Methods]]
###### 10. [[#Lists]]
###### 11. [[#Error Types]]
###### 12. [[#Exceptions]]
###### 13. [[#Cool things to keep in mind]]
###### 16. [[#How to read Python]]
###### 17. [[#Examples]]

#### Intro to Programming
A program makes a computer usable. Without a program, a computer, even the most powerful one, is nothing more than an object. Similarly, without a player, a piano is nothing more than a wooden box.

Computers are able to perform very complex tasks, but this ability is not innate. A computer's nature is quite different.

It can execute only extremely simple operations. For example, a computer cannot understand the value of a complicated mathematical function by itself, although this isn't beyond the realms of possibility in the near future.

Contemporary computers can only evaluate the results of very fundamental operations, like adding or dividing, but they can do it very fast, and can repeat these actions virtually any number of times.

A computer, even the most technically sophisticated, is devoid of even a trace of intelligence. You could say that it is like a well-trained dog - it responds only to a predetermined set of known commands.
##### Computers are Binary
The name 'boolean' comes from George Boole (1815-1864), the author of the fundamental work, _The Laws of Thought_, which contains the definition of **Boolean algebra** ‒ a part of algebra which makes use of only two distinct values: `True` and `False`, denoted as `1` and `0`.

A programmer writes a program, and the program asks questions. A computer executes the program, and provides the answers. The program must be able to react according to the received answers.

Fortunately, computers know only two kinds of answers:

- Yes, this is true;
- No, this is false.

You'll never get a response like: _I don't know_ or _Probably yes, but I don't know for sure_.

False is when all the bits are reset;
True is when at least one bit is set.
##### Actions that form a Program
Imagine that you want to know the average speed you've reached during a long journey. You know the distance, you know the time, you need the speed.

Naturally, the computer will be able to compute this, but the computer is not aware of such things as distance, speed, or time. Therefore, it is necessary to instruct the computer to:

1. Input
	- accept a number representing the distance;
	- accept a number representing the travel time;
2. Processing
	- divide the former value by the latter and store the result in the memory;
3. Output
	- display the result (representing the average speed) in a readable format.

These four simple actions form a **program**. Of course, these examples are not formalized, and they are very far from what the computer can understand, but they are good enough to be translated into a language the computer can accept.

**Language** is the keyword.
##### Language elements
While we humans communicate through natural languages, computers communicate through machine language, which is very rudimentary, both of which consist of the following:
1. Alphabet
2. Lexis
3. Syntax
4. Semantics
##### Computer Programming
Computer programming is the act of composing the selected programming language's elements in the order that will cause the desired effect. The effect could be different in every specific case – it's up to the programmer's imagination, knowledge and experience.

Of course, such a composition has to be correct in many senses:

- **alphabetically** – a program needs to be written in a recognizable script, such as Roman, Cyrillic, etc.
- **lexically** – each programming language has its dictionary and you need to master it; thankfully, it's much simpler and smaller than the dictionary of any natural language;
- **syntactically** – each language has its rules and they must be obeyed;
- **semantically** – the program has to make sense.

Unfortunately, a programmer can also make mistakes with each of the above four senses. Each of them can cause the program to become completely useless.

Let's assume that you've successfully written a program. How do we persuade the computer to execute it? You have to render your program into machine language. Luckily, the translation can be done by a computer itself, making the whole process fast and efficient.
##### Compilation vs Interpretation
There are two different ways of **transforming a program from a high-level programming language into machine language**:
1. COMPILATION
- Doesn't need compiler to run (after being compiled)
- The execution is usually faster, but the code can't be easily edited
- May take time to fully compile
- Source code is hidden from the user and can't be shared easily as it needs to be compiled for each kind of architecture

2. INTERPRETATION
- Needs interpreter to run
- Usually slower than compiled because the computer resources are shared among the source program and the interpreter itself
- Is executed instantly, line by line
- Source code is easily shareable and works anywhere there is a interpreter
##### What does the interpreter do?
Let's assume once more that you have written a program. Now, it exists as a **computer file**: a computer program is actually a piece of text, so the source code is usually placed in **text files**.

Note: it has to be **pure text**, without any decorations like different fonts, colors, embedded images or other media. Now you have to invoke the interpreter and let it read your source file.

The interpreter reads the source code in a way that is common in Western culture: from top to bottom and from left to right. There are some exceptions - they'll be covered later in the course.

First of all, the interpreter checks if all subsequent lines are correct (using the four aspects covered earlier).

If the compiler finds an error, it finishes its work immediately. The only result in this case is an **error message**.

The interpreter will inform you where the error is located and what caused it. However, these messages may be misleading, as the interpreter isn't able to follow your exact intentions, and may detect errors at some distance from their real causes.

For example, if you try to use an entity of an unknown name, it will cause an error, but the error will be discovered in the place where it tries to use the entity, not where the new entity's name was introduced.

In other words, the actual reason is usually located a little earlier in the code, for example, in the place where you had to inform the interpreter that you were going to use the entity of the name.

If the line looks good, the interpreter tries to execute it (note: each line is usually executed separately, so the trio "read-check-execute" can be repeated many times - more times than the actual number of lines in the source file, as some parts of the code may be executed more than once).

It is also possible that a significant part of the code may be executed successfully before the interpreter finds an error. This is normal behavior in this execution model.

You may ask now: which is better? The "compiling" model or the "interpreting" model? There is no obvious answer. If there had been, one of these models would have ceased to exist a long time ago. Both of them have their advantages and their disadvantages.

---
#### Python is
- a high-level interpreted programming language with dynamic semantics
- an interpreted programming language
- object-oriented
- used for general-purpose programming
- easy and intuitive, understandable, suitable for everyday tasks
- easy to learn, teach, use, understand, obtain

---
#### Best practices
- Functions: The name of the function should be **significant** (the name of the print function is self-evident).
- Comments: Comments are very important. They are used not only to make your programs **easier to understand**, but also to **disable those pieces of code that are currently not needed** (e.g., when you need to test some parts of your code only, and ignore others).
- Variable names: Whenever possible and justified, you should give self-commenting names to variables, e.g., if you're using two variables to store the length and width of something, the variable names `length` and `width` may be a better choice than `myvar1` and `myvar2`.
- It's good to **describe** each important piece of code with comments, use **self-commenting** and **readable** (non-confusing) variable names, and sometimes it's better to **divide your code** into named pieces (e.g., functions). In some situations, it's a good idea to write the steps of computations in a clearer way.
- Don't feel obliged to code your programs in a way that is always the shortest and the most compact. Readability may be a more important factor. Keep your code ready for a new programmer.
- **Using the same name of a built-in Python function as a variable name would generally be considered bad practice**. Ex.: using `sum` considering there already is  `sum()`
- **if a particular fragment of the code begins to appear in more than one place, consider the possibility of isolating it in the form of a function** invoked from the points where the original code was placed before.
- **if a piece of code becomes so large that reading and understating it may cause a problem, consider dividing it into separate, smaller problems, and implement each of them in the form of a separate function**
- if you're going to divide the work among multiple programmers, **decompose the problem to allow the product to be implemented as a set of separately written functions packed together in different modules**.
- 

---
#### Python Built-In Data Types
1. None Type: `None` is a `NoneType` object, and it is used to represent **the absence of a value**. There are only two kinds of circumstances when `None` can be safely used:
	- when you **assign it to a variable** (or return it as a **function's result**)
	- when you **compare it with a variable** to diagnose its internal state.
2. Numeric Types: all support arithmetic; represent numerical quantities; NOT containers; IMMUTABLE
	- Integers (`int`): whole numbers. Ex.: `5`
	- Floats (`float`): numbers with decimals. Ex.: `3.14`
	- Complex (`complex`): numbers that store real + imaginary. Ex.: `2+3j`
3. Boolean Type (`bool`): equals `True` or `False`
4. Text Type:
	- Strings (`str`): represents human text; supports slicing, indexing; IMMUTABLE, cannot do math, behaves like a character sequence
5. Sequence (Ordered container) Types: store multiple values; keep order; allow indexing and iteration; **NOT** sets
	- Lists `list`: resizable array of values; **MUTABLE** (i.e. references a place in memory which if altered through another variable also alters this because these just reference the same value in memory)
	- Tuple `tuple`: fixed array of values; **IMMUTABLE**
	- Range `range`: efficient sequence of integers; **IMMUTABLE**
6. Set Types: do **NOT** keep order (**UNORDERED**); do **NOT** allow duplicates; support mathematical set operations
	- Set (`set`): **MUTABLE**
	- Frozen Set (`frozenset`): **IMMUTABLE**
7. Mapping Type: stores **key → value pairs**, not just values; fast lookup by key; internal structure is a **hash table**
	- Dictionary (`dict`): **MUTABLE**
8. Binary Types: represent raw bytes, not characters, not numbers. Used for networking, cryptography, file manipulation, image/audio processing
	- `bytes`: raw binary data; **IMMUTABLE**
	- `bytearray`: modifiable binary data; **MUTABLE**
	- `memoryview`: view into another binary buffer; **IMMUTABLE**
9. Callable / Class / Function Types: Python treats functions, methods, and classes as data (you can store them, move them around, and use them as data)
	- Functions: can be stored in variables, passed as arguments
	- Classes: blueprint for objects
	- Methods: function bound to an object
10. Special / Internal Types: exist mostly for advanced use

|Type|Example|Purpose|
|---|---|---|
|`type`|type(x)|metaclass of all classes|
|`object`|root of everything||
|`ellipsis`|`...`|used in slicing (rare)|
|`NotImplementedType`|`NotImplemented`|used in operator overloading|

---
#### Python Keywords
##### Known
```python
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

False, True  # boolean values, 0 and 1
None  # Null equivalent in python, it means the absence of value
if, elif, else  # conditions for decisions
pass  # empty instruction to bypass syntax demands of if, elif, else, while, for, etc
while, for, break, continue, else  # loops
and, or, not  # logical operators
del  # instruction used to delete a list element, slices and/or the list itself
in, not in  # check whether a specific value is stored inside a list or not
def, return, None  # functions, return is a instruction
is  # comparison with None
global  # used to allow assigning values to variables outside of a function's scope

import, from, as  # working with modules and libraries
try, except, finally, raise  # validation
with, as  # working with files

```

##### Need to learn
'assert', 'class', '', 'lambda', 'nonlocal', 'yield'

---
#### Operators by priority
- **Basic:** `**`; unary `+`, unary `-`; `*`, `/`, `//`, `%`; binary `+`, binary `-`
- **Shift**: `<<` and `>>` (pair of digraphs)
- **Comparison/Relational**: `>` (greater than), `>=` (greater than or equal to), `<` (less than), `<=` (less than or equal to); `==` (equal to), `!=` (not equal to)
- **Logical**: `not` (negation); `and` (conjunction); `or` (disjunction)
- **Assignment:** `=`
- **Shortcut**: `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`


- **Bitwise** (abbreviated form): `~` (negation); `&` (conjunction); `^` (XOR); `|` (disjunction)
> [!NOTE]- More about bitwise operations
> - **Bitwise**: allow you to **manipulate single bits of data**. The arguments of these operators **must be integers**. The difference in the operation of the logical and bit operators is important: **the logical operators do not penetrate into the bit level of its argument**. They're only interested in the final integer value. Bitwise operators are stricter: they deal with **every bit separately**.
> 	- `&` (ampersand) ‒ bitwise conjunction;
> 	- `|` (bar) ‒ bitwise disjunction;
> 	- `~` (tilde) ‒ bitwise negation;
> 	- `^` (caret) ‒ bitwise exclusive or (xor).
> 
> Bitwise operations (&, |, and ^)
> 
> | Argument A | Argument B | A & B | A \| B | A ^ B |
> | ---------- | ---------- | ----- | ------ | ----- |
> | 0          | 0          | 0     | 0      | 0     |
> | 0          | 1          | 0     | 1      | 1     |
> | 1          | 0          | 0     | 1      | 1     |
> | 1          | 1          | 1     | 1      | 0     |
> 
> Bitwise operations (~)
>  
> | Argument | ~ Argument |
> | -------- | ---------- |
> | 0        | 1          |
> | 1        | 0          |
> 
> Let's make it easier:
> - `&` requires exactly two 1s to provide 1 as the result;
> - `|` requires at least one 1 to provide 1 as the result;
> - `^` requires exactly one 1 to provide 1 as the result.
> 
> Examples:
> ```python
> i = 15
> j = 22
> 
> ### Conjunction:
> log = i and j # log == True
> 
> bit = i & j # bit == 6
> # because
> #   i: 00000000000000000000000000001111
> #   j: 00000000000000000000000000010110
> # bit: 00000000000000000000000000000110
> 
> ### Negation:
> logneg = not i # logneg == False
> 
> bitneg = ~i # bitneg == -16
> # because
> #      i: 00000000000000000000000000001111
> # bitneg: 11111111111111111111111111110000
> # If we interpret that as an **unsigned** 8-bit number, it would be **240**.
> # But Python integers are **signed** (they can be negative), and it uses
> # **two’s complement** logic to handle signs conceptually.
> # So to find its decimal value:
> # 1. Invert the bits
> #	 → `00000000000000000000000000001111`
> # 2. Add 1  
> #    → `00000000000000000000000000010000` = 16
> # 3. Then put the negative sign:
> #    → `-16`
> ```
> 
> You can use bitwise operators to manipulate single bits of data. The following sample data:
> 
> - `x = 15`, which is `0000 1111` in binary,
> - `y = 16`, which is `0001 0000` in binary.
> 
> will be used to illustrate the meaning of bitwise operators in Python. Analyze the examples below:
> 
> - `&` does a _bitwise and_, e.g., `x & y = 0`, which is `0000 0000` in binary,
> - `|` does a _bitwise or_, e.g., `x | y = 31`, which is `0001 1111` in binary,
> - `˜` does a _bitwise not_, e.g., `˜ x = 240`\*, which is `1111 0000` in binary,
> - `^` does a _bitwise xor_, e.g., `x ^ y = 31`, which is `0001 1111` in binary,
> - `>>` does a _bitwise right shift_, e.g., `y >> 1 = 8`, which is `0000 1000` in binary,
> - `<<` does a _bitwise left shift_, e.g., `y << 3 = 128`, which is `1000 0000` in binary.
> 
> * -16 (decimal from signed 2's complement) -- read more about the [Two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) operation.
>
> #### Binary left shift and binary right shift
> 
> Python offers yet another operation relating to single bits: **shifting**. This is applied only to **integer** values, and you mustn't use floats as arguments for it.
> 
> You already apply this operation very often and quite unconsciously. How do you multiply any number by ten? Take a look:
> 
> 12345 × 10 = 123450
> 
> As you can see, **multiplying by ten is in fact a shift** of all the digits to the left and filling the resulting gap with zero.
> 
> Division by ten? Take a look:
> 
> 12340 ÷ 10 = 1234
> 
> Dividing by ten is nothing but shifting the digits to the right.
> 
> The same kind of operation is performed by the computer, but with one difference: as two is the base for binary numbers (not 10), **shifting a value one bit to the left thus corresponds to multiplying it by two**; respectively, **shifting one bit to the right is like dividing by two** (notice that the rightmost bit is lost).
> 
> The **shift operators** in Python are a pair of **digraphs**: `<<` and `>>`, clearly suggesting in which direction the shift will act.
> 
> ```
> value << bits
> value >> bits
>  
> ```
> 
> **The left argument of these operators is an integer value whose bits are shifted. The right argument determines the size of the shift.**
> 
> It shows that this operation is certainly not commutative.
> 
> The priority of these operators is very high. You'll see them in the updated table of priorities, which we'll show you at the end of this section.
> 
> Take a look at the shifts in the editor window.
> 
> ```python
> var = 17
> var_right = var >> 1
> var_left = var << 2
> print(var, var_left, var_right)
> 
> ```
> 
> The final `print()` invocation produces the following output:
> 
> ```Output
> 17 68 8
> ```
> 
> Note:
> 
> - `17 >> 1` → `17 // 2` (**17** floor-divided by **2 to the power of 1**) → `8` (shifting to the right by one bit is the same as integer division by two)
> - `17 << 2` → `17 * 4` (**17** multiplied by **2 to the power of 2**) → `68` (shifting to the left by two bits is the same as integer multiplication by four)

| Priority | Operator                                                                                                                                                                                    | Notes  | Type                                                                                  |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ | ------------------------------------------------------------------------------------- |
| 1        | <code>~</code>, <code>+</code>, <code>-</code>                                                                                                                                              | unary  | tilde (Bitwise Negation), unary plus/minus (Arithmetic)                               |
| 2        | <code>**</code>                                                                                                                                                                             |        | exponentiation (Arithmetic)                                                           |
| 3        | <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>                                                                                                                             |        | multiplication, division, floor/integer division, modulo (Arithmetic)                 |
| 4        | <code>+</code>, <code>-</code>                                                                                                                                                              | binary | binary plus/minus (Arithmetic)                                                        |
| 5        | <code><<</code>, <code>>></code>                                                                                                                                                            |        | pair of digraphs (Bitwise Shift)                                                      |
| 6        | <code><</code>, <code><=</code>, <code>></code>, <code>>=</code>                                                                                                                            |        | less than, less than or equal to, greater than, greater than or equal to (Comparison) |
| 7        | <code>==</code>, <code>!=</code>                                                                                                                                                            |        | equality, inequality (Comparison)                                                     |
| 8        | <code>&</code>                                                                                                                                                                              |        | ampersand (Bitwise Conjunction)                                                       |
| 9        | <code>^</code>                                                                                                                                                                              |        | caret (Bitwise Exclusive or)                                                          |
| 10       | <code>\|</code>                                                                                                                                                                             |        | bar (Bitwise Disjunction)                                                             |
| 11       | <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&=</code>, <code>^=</code>, <code>\|=</code>, <code>>>=</code>, <code><<=</code> |        | Assignment Operator + Shortcuts/Abbreviated Forms                                     |

| Priority | Operators            | Description                                      |
| -------- | -------------------- | ------------------------------------------------ |
| 1        | `+`, `-` (unary)     | Unary plus/minus (e.g., `-x`, `+y`)              |
| 2        | `**`                 | Exponentiation                                   |
| 3        | `*`, `/`, `//`, `%`  | Multiplication, division, floor division, modulo |
| 4        | `+`, `-` (binary)    | Binary addition and subtraction                  |
| 5        | `<`, `<=`, `>`, `>=` | Comparison operators                             |
| 6        | `==`, `!=`           | Equality and inequality                          |

---
#### Conditional Execution/Instruction/Statement
There's at least two possibilities on how to make use of the boolean answers the computer gives to comparison questions:
1. Memorize it (store it in a variable) and make use of it later
2. Use the answer you get to make a decision about the future of the program

---
#### Functions
> [!NOTE]-
> ##### Why do we need functions?
> 
> You've come across **functions** many times so far, but the view on their merits that we have given you has been rather one-sided. You've only invoked functions by using them as tools to make life easier, and to simplify time-consuming and tedious tasks.
> 
> When you want some data to be printed on the console, you use `print()`. When you want to read the value of a variable, you use `input()`, coupled with either `int()` or `float()`.
> 
> You've also made use of some **methods**, which are in fact functions, but declared in a very specific way.
> 
> Now you'll learn how to write and use your own functions. We'll write several functions together, from the very simple to the rather complex, which will require your focus and attention.
> 
> It often happens that a particular piece of code is **repeated many times in your program**. It's repeated either literally, or with only a few minor modifications, consisting of the use of other variables in the same algorithm. It also happens that a programmer cannot resist simplifying their work, and begins to clone such pieces of code using the clipboard and copy-paste operations.
> 
> It could end up as greatly frustrating when suddenly it turns out that there was an error in the cloned code. The programmer will have a lot of drudgery to find all the places that need corrections. There's also a high risk of the corrections causing errors.
> 
> We can now define the first condition which can help you decide when to start writing your own functions: **if a particular fragment of the code begins to appear in more than one place, consider the possibility of isolating it in the form of a function** invoked from the points where the original code was placed before.
> 
> It may happen that the algorithm you're going to implement is so complex that your code begins to grow in an uncontrolled manner, and suddenly you notice that you're not able to navigate through it so easily anymore.
> 
> You can try to cope with the issue by commenting the code extensively, but soon you find that this dramatically worsens your situation ‒ **too many comments make the code larger and harder to read**. Some say that a **well-written function should be viewed entirely in one glance**.
> 
> A good, attentive developer **divides the code** (or more accurately: the problem) into well-isolated pieces, and **encodes each of them in the form of a function**.
> 
> This considerably simplifies the work of the program, because each piece of code can be encoded separately, and tested separately. The process described here is often called **decomposition**.
> 
> We can now state the second condition: **if a piece of code becomes so large that reading and understating it may cause a problem, consider dividing it into separate, smaller problems, and implement each of them in the form of a separate function**.
> 
> This decomposition continues until you get a set of short functions, easy to understand and test.
> 
> ##### Decomposition
> 
> It often happens that the problem is so large and complex that it cannot be assigned to a single developer, and a **team of developers** have to work on it. The problem must be split between several developers in a way that ensures their efficient and seamless cooperation.
> 
> It seems inconceivable that more than one programmer should write the same piece of code at the same time, so the job has to be dispersed among all the team members.
> 
> This kind of decomposition has a different purpose to the one described previously ‒ it's not only about **sharing the work**, but also about **sharing the responsibility** among many developers.
> 
> Each of them writes a clearly defined and described set of functions, which when **combined into the module** (we'll tell you about this a bit later) will give the final product.
> 
> This leads us directly to the third condition: if you're going to divide the work among multiple programmers, **decompose the problem to allow the product to be implemented as a set of separately written functions packed together in different modules**.
- A function is a block of code that performs a specific task when the function is called (invoked). You can use functions to make your code reusable, better organized, and more readable. Functions can have parameters and return values.
- Functions may have none or many (positional/keyword) parameters meaning they take none or many arguments and either:
	1. **cause some effect** (e.g., send text to the terminal, create a file, draw an image, play a sound, etc.); this is something completely unheard of in the world of mathematics. Ex.: `print()`
	2. **evaluate a value** (e.g., the square root of a value or the length of a given text) and **return it as the function's result**; this is what makes Python functions the relatives of mathematical concepts. Ex.: `sqrt()`
- Functions come from Python itself (built-in), from pre-installed modules, from your code and the `lambda`functions.
- **You mustn't invoke a function which is not known at the moment of invocation.**
- **You mustn't have a function and a variable of the same name**.
- You can pass information to functions by using parameters. Your functions can have as many parameters as you need.
	- The function's full power reveals itself when it can be equipped with an interface that is able to accept data provided by the invoker. Such data can modify the function's behavior, making it more flexible and adaptable to changing conditions.
	- A parameter is actually a variable, but there are two important factors that make parameters different and special:
		- **parameters exist only inside functions in which they have been defined**, and the only place where the parameter can be defined is a space between a pair of parentheses in the `def` statement;
		- **assigning a value to the parameter is done at the time of the function's invocation**, by specifying the corresponding argument.
	- Don't forget:
		- **parameters live inside functions** (this is their natural environment)
		- **arguments exist outside functions**, and are carriers of values passed to corresponding parameters.
		- There is a clear and unambiguous frontier between these two worlds.
	- A value for the parameter will arrive from the function's environment.
	- Remember: **specifying one or more parameters in a function's definition** is also a requirement, and you have to fulfil it during invocation. You must **provide as many arguments as there are defined parameters**. Failure to do so will cause an error.
- You can pass arguments to a function using the following techniques:
	- **positional argument passing** in which the order of arguments passed matters (Ex. 1)
	- **keyword (named) argument passing** in which the order of arguments passed doesn't matter (Ex. 2)
	- a mix of positional and keyword argument passing (Ex. 3.)
```python
Ex. 1
def subtra(a, b):
    print(a - b)

subtra(5, 2)    # outputs: 3
subtra(2, 5)    # outputs: -3


Ex. 2
def subtra(a, b):
    print(a - b)

subtra(a=5, b=2)    # outputs: 3
subtra(b=2, a=5)    # outputs: 3

Ex. 3
def subtra(a, b):
    print(a - b)

subtra(5, b=2)    # outputs: 3
subtra(5, 2)    # outputs: 3

```

- It's important to remember that **positional arguments mustn't follow keyword arguments**. That's why if you try to run the following snippet:
```python
def subtra(a, b):
    print(a - b)

subtra(5, b=2)    # outputs: 3
subtra(a=5, 2)    # Syntax Error

```

Python will not let you do it by signalling a `SyntaxError`.

- You can use the keyword argument-passing technique to **pre-define** a value for a given argument:
```python
def name(first_name, last_name="Smith"):
    print(first_name, last_name)

name("Andy")    # outputs: Andy Smith
name("Betty", "Johnson")    # outputs: Betty Johnson (the keyword argument replaced by "Johnson")

```

- The `return` instruction has **two different variants**:
	- `return`without an expression causes a function's termination
	- `return` with an expression causes the **immediate termination of the function's execution** (just like before), moreover, the function will **evaluate the expression's value and will return it (hence the name once again) as the function's result**.
- The `return` instruction, enriched with the expression (the expression is very simple here), "transports" the expression's value to the place where the function has been invoked.
	- Don't forget:
		- you are always **allowed to ignore the function's result**, and be satisfied with the function's effect (if the function has any)
		- if a function is intended to return a useful result, it must contain the second variant of the `return` instruction.
- Don't forget this: if a function doesn't return a certain value using a `return` expression clause, it is assumed that it **implicitly returns `None`**.
##### Known Functions
`print()`, `round()`, `input()`, `int()`, `float()`, `str()`, `max()`, `min()`, `range()` (`float`), `time.sleep()`, `len()` (lists)

##### Important things to know about functions:
- `print()` can work with octal and hex values: `print(0o10)` equals `8` while `print(0x10)` equals `16`
	- Note: `oct()` and `hex()` can be used for type casting
- `round()`: signature `round(number[, ndigits])`, numbers **less than .5** round down, numbers **greater than .5** round up, but numbers **exactly at .5 are an exception**: Python uses Round Half to Even rounding.

> [!EXAMPLE]- Demonstration
> ```python
> >>> x = 10.501
> >>> round(x, -1) # nearest multiple of 10
> 10.0
> >>> round(x) # nearest integer
> 11
> >>> round(x, 0) # same but with the floating point
> 11.0
> >>> round(x, 1) # 1 decimal place
> 10.5
> >>> round(x, 2) # 2 decimal places
> 10.5
> >>> round(x, 3) # 3 decimal places
> 10.501
> >>> round(x, 4) # 4 decimal places
> 10.501
> 
> >>> x = -10.501
> >>> round(x, -1)
> -10.0
> >>> round(x, 0)
> -11.0
> >>> round(x, 1)
> -10.5
> >>> round(x, 2)
> -10.5
> >>> round(x, 3)
> -10.501
> >>> round(x, 4)
> -10.501
> ```

> [!NOTE]- Round Half to Even (Banker's Rounding, IEEE 754 Standard)
> 
> `.5` values round toward the **nearest even integer**, not always up, to keep results statistically unbiased across large datasets.
> 
> |Value|Nearest Integers|Rounded To|Reason|
> |:-:|:-:|:-:|:--|
> |-12.5|[-12] , -13|**-12**|-12 is even|
> |-11.5|-11 , [-12]|**-12**|-12 is even|
> |-10.5|[-10] , -11|**-10**|-10 is even|
> |-9.5|-9 , [-10]|**-10**|-10 is even|
> |-8.5|[-8] , -9|**-8**|-8 is even|
> |-7.5|-7 , [-8]|**-8**|-8 is even|
> |-6.5|[-6] , -7|**-6**|-6 is even|
> |-5.5|-5 , [-6]|**-6**|-6 is even|
> |-4.5|[-4] , -5|**-4**|-4 is even|
> |-3.5|-3 , [-4]|**-4**|-4 is even|
> |-2.5|[-2] , -3|**-2**|-2 is even|
> |-1.5|-1 , [-2]|**-2**|-2 is even|
> |-0.5|[0] , -1|**0**|0 is even|
> |0.5|[0] , 1|**0**|0 is even|
> |1.5|1 , [2]|**2**|2 is even|
> |2.5|[2] , 3|**2**|2 is even|
> |3.5|3 , [4]|**4**|4 is even|
> |4.5|[4] , 5|**4**|4 is even|
> |5.5|5 , [6]|**6**|6 is even|
> |6.5|[6] , 7|**6**|6 is even|
> |7.5|7 , [8]|**8**|8 is even|
> |8.5|[8] , 9|**8**|8 is even|
> |9.5|9 , [10]|**10**|10 is even|
> |10.5|[10] , 11|**10**|10 is even|
> |11.5|11 , [12]|**12**|12 is even|
> |12.5|[12] , 13|**12**|12 is even|
> 

- `range()` (<code>range(start, stop[, step])</code>) works both ways: `range(1, 5, 1)` equals `1234` while `range(1, 5, -1)` equals `5432`

#### Scopes
- _The **scope of a name** (e.g., a variable name) is the part of a code where the name is properly recognizable._ For example, the scope of a function's parameter is the function itself. The parameter is inaccessible outside the function.
- **A variable existing outside a function has scope inside the function's body, excluding those which define a variable of the same name.** It also means that the **scope of a variable existing outside a function is supported only when getting its value** (reading). Assigning a value forces the creation of the function's own variable.
- There's a special Python method which can **extend a variable's scope in a way which includes the function's body** (even if you want not only to read the values, but also to modify them): `global`. You can use the `global` keyword followed by a variable name to make the variable's scope global
	- Using this keyword inside a function with the name (or names separated with commas) of a variable (or variables), forces Python to refrain from creating a new variable inside the function ‒ the one accessible from outside will be used instead. In other words, this name becomes global (it has **global scope**, and it doesn't matter whether it's the subject of read or assign).
- **changing the parameter's value doesn't propagate outside the function** (in any case, not when the variable is a scalar, like in the example). This also means that a function receives the **argument's value**, not the argument itself. This is true for scalars.
- if the argument is a list, then changing the value of the corresponding parameter doesn't affect the list (remember: variables containing lists are stored in a different way than scalars), but if you change a list identified by the parameter (note: the list, not the parameter!), the list will reflect the change.
#### Methods
- A **method is a specific kind of function** ‒ it behaves like a function and looks like a function, but differs in the way in which it acts, and in its invocation style.
- A **function doesn't belong to any data** ‒ it gets data, it may create new data and it (generally) produces a result. A method does all these things, but is also able to **change the state of a selected entity**.
- **A method is owned by the data it works for, while a function is owned by the whole code**. This also means that invoking a method requires some specification of the data from which the method is invoked.

It may sound puzzling here, but we'll deal with it in depth when we delve into object-oriented programming.

In general, a typical function invocation may look like this:

```
result = function(arg) 
```

The function takes an argument, does something, and returns a result.

A typical method invocation usually looks like this:

```
result = data.method(arg) 
```

Note: the name of the method is preceded by the name of the data which owns the method. Next, you add a **dot**, followed by the **method name**, and a pair of **parenthesis enclosing the arguments**.

The method will behave like a function, but can do something more ‒ it can **change the internal state of the data** from which it has been invoked.

This is an essential issue right now, as we're going to show you how to add new elements to an existing list. This can be done with methods owned by all the lists, not by functions.

##### Known Methods:
```python
time.sleep() # `sleep()` is a **function** defined in the `time` module, and when you call it as `time.sleep()`, it behaves like a method of that module.
list.append(value) # It takes its argument's value and puts it **at the end of the list** which owns the method.
list.insert(location, value) # it can add a new element **at any place in the list**, not only at the end
list.sort() # to timsort in ascending order (default)
list.reverse() # to reverse a list order by swapping the first element with the last and so on
```

---
#### Lists
**Why do we need lists?** It may happen that you have to read, store, process, and finally, print dozens, maybe hundreds, perhaps even thousands of numbers. To make this process simpler, instead of needing to create and use multiple **scalar** variables (able to store exactly one given value at a time), you may use a **list** (variable that can **store more than one value**) to store multiple values.

The **list is a type of data** in Python used to **store multiple objects**. It is an **ordered and mutable collection** of comma-separated items between square brackets, e.g.: `my_list = [1, None, True, "I am a string", 256, 0]`. Lists can be **nested**, e.g.: `my_list = [1, 'a', ["list", 64, [0, 1], False]]`
##### Indexing
In order to facilitate the selection of any list element, Python has adopted a convention stating that the elements in a list are **always numbered starting from zero**. This means that the item stored at the beginning of the list will have the number zero (**index**).

The value inside the brackets which selects one element of the list is called an **index**, while the operation of selecting/retrieving or modifying an element from the list by index is known as **indexing**.

An element with an index equal to `-1` is **the last one in the list**. Similarly, the element with an index equal to `-2` is **the one before last in the list**.
###### Operations by index
```python
numbers = [10, 5, 7, 2, 1]
print("Original list contents:", numbers)  # Output: [10, 5, 7, 2, 1]

numbers[0] = 111  # Accessing the list's first element and replacing its value
print("\nPrevious list contents:", numbers)  # Output: [111, 5, 7, 2, 1]

numbers[1] = numbers[4]  # Copying value of the fifth element to the second.
print("New list contents:", numbers)  # Output: [111, 1, 7, 2, 1]

print("\nList's length:", len(numbers))  # Printing previous list length. Output: 5

del numbers[1]  # Removing the second element from the list.
print("New list's length:", len(numbers))  # Printing new list length. Output: 4
print("\nNew list content:", numbers)  # Output: [111, 7, 2, 1]

print(numbers[-1])  # Output: 1
print(numbers[-2])  # Output: 2

del numbers  # Deletes the whole list

###
my_list = [10, 1, 8, 3, 5]
total = 0

for i in range(len(my_list)):
    total += my_list[i]

print(total)  # Output: 27
```
###### Operations without index
```python
# By iteration:
my_list = [10, 1, 8, 3, 5]
total = 0

for i in my_list:
    total += i

print(total)  # Output: 27
```
###### Operations by methods
A method can **change the internal state of the data** from which it has been invoked.
- `list.append(value)`: takes its argument's value and puts it **at the end of the list** which owns the method.
- `list.insert(location, value)`: adds a new element **at any place in the list**, not only at the end. It takes two arguments:
	- the first shows the required location of the element to be inserted; note: all the existing elements that occupy locations to the right of the new element (including the one at the indicated position) are shifted to the right, in order to make space for the new element;
	- the second is the element to be inserted.
- `list.reverse()`: reverses the list
> [!EXAMPLE]- More about `.reverse()`
> Considering `my_list = [10, 1, 8, 3, 5]`, `my_list.reverse()` does the same as:
> ```python
> my_list = [10, 1, 8, 3, 5]
> 
> my_list[0], my_list[4] = my_list[4], my_list[0]
> my_list[1], my_list[3] = my_list[3], my_list[1]
> 
> print(my_list)  # Output: [5, 3, 8, 1, 10]
> ```
> or better yet:
> ```python
> my_list = [10, 1, 8, 3, 5]
> length = len(my_list)
> 
> for i in range(length // 2):
>     my_list[i], my_list[length - i - 1] = my_list[length - i - 1], my_list[i]
> 
> print(my_list)  # Output: [5, 3, 8, 1, 10]
> ```
- `list.sort()`: sorts the elements of a list
> [!EXAMPLE]- More about `.sort()`
> Considering `my_list = [8, 10, 6, 2, 4]`, `my_list.sort()` does better than the following because it uses Timsort instead of Bubble sort:
> ```python
my_list = [8, 10, 6, 2, 4]  # list to sort
swapped = True  # It's a little fake, we need it to enter the while loop.
> 
> while swapped:
>     swapped = False  # no swaps so far
>     for i in range(len(my_list) - 1):
>         if my_list[i] > my_list[i + 1]:
>             swapped = True  # a swap occurred!
>             my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]
> 
> print(my_list)  # Output: [2, 4, 6, 8, 10]
> ```
> or
> ```python
> my_list = []
swapped = True
num = int(input("How many elements do you want to sort: "))
> 
> for i in range(num):
>     val = float(input("Enter a list element: "))
>     my_list.append(val)
> 
> while swapped:
>     swapped = False
>     for i in range(len(my_list) - 1):
>         if my_list[i] > my_list[i + 1]:
>             swapped = True
>             my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]
> 
> print("\nSorted:")
> print(my_list)
> ```

```python
numbers = [111, 7, 2, 1]
print(f"Length: {len(numbers)} | List: {numbers}")

numbers.append(4)
print(f"Length: {len(numbers)} | List: {numbers}")

numbers.insert(0, 222)  # method + indexing
print(f"Length: {len(numbers)} | List: {numbers}")

numbers.insert(1, 333)  # method + indexing
print(f"Length: {len(numbers)} | List: {numbers}")

lst = [5, 3, 1, 2, 4]
lst.sort()
print(lst)  # outputs: [1, 2, 3, 4, 5]

lst = ["D", "F", "A", "Z"]
lst.sort()
print(lst)  # Output: ['A', 'D', 'F', 'Z']

lst = [5, 3, 1, 2, 4]
lst.reverse()
print(lst)  # outputs: [4, 2, 1, 3, 5]
```

> [!WARNING]- IMPORTANT - A list content is referenced not named
> While the name of an ordinary variable is the **name of its content**, the name of a list is the name of a **memory location where the list is stored**. Therefore, assigning a list to another list then modifying the latter will also alter the former as both identify the same location in computer memory.
> 
> ```python
> list_1 = [1]
> list_2 = list_1
> list_1[0] = 2
> print(list_2)  # Output: [2]
> ```
> 
> Use *slicing* instead.
##### Slicing
A **slice** is an element of Python syntax that allows you to **make a brand new copy of a list, or parts of a list**. It actually copies the list's contents, not the list's name.

Syntax: `my_list[start:end]`
- `start` is the index of the first element **included in the slice**. If you omit the `start` in your slice, it is assumed that you want to get a slice beginning at the element with index `0`.
- `end` is the index of the first element **not included in the slice**. Similarly, if you omit the `end` in your slice, it is assumed that you want the slice to end at the element with the index `len(my_list)`.
- A slice of this form **makes a new (target) list, taking elements from the source list ‒ the elements of the indices from `start` to `end - 1`.**
	- Note: not to `end` but to `end - 1`. An element with an index equal to `end` is the first element which **does not take part in the slicing**.
- Using negative values for both start and end is possible (just like in indexing).
	- Note: If the `start` specifies an element lying further than the one described by the `end` (from the list's beginning), the slice will be **empty**.
###### Slicing Operations
Considering: `my_list = [10, 8, 6, 4, 2]`
- `my_list[start:]` means `my_list[start:len(my_list)]` so, `new_list = my_list[3:]` equals `[4, 2]`
- `my_list[:end]` means `my_list[0:end]` so, `new_list = my_list[:3]` equals `[10, 8, 6]`
- `my_list[:]` selects an entire list: `[10, 8, 6, 4, 2]`
- `my_list[1:3]` the more precise way of **slicing**: `[8, 6]`
	- Starts at element 2 (index `1`);
	- Ends **with** element 3 (index `2`) **right before** element 4 (index `3`)
- `my_list[1:-1]` selects anything from index `1` until the last list element (`-1`): `[8, 6, 4]`
- `my_list[-1:1]` equals `[]`
- `del my_list[1:3]` deletes slices, so `[10, 4, 2]`
- `del my_list[:]` deletes all elements, so `[]`
- `del my_list` deletes the list itself not its content, so if `new_list = my_list` before deletion, `new_list`equals `[10, 8, 6, 4, 2]`

##### List comprehensions
- A special syntax used by Python in order to fill massive lists which allows you to create new lists from existing ones in a concise and elegant way.
- The syntax of a list comprehension looks as follows: `[expression for element in list if conditional]` which is actually an equivalent of the following code:
```
for element in list:
    if conditional:
        expression 
```
- It is actually a list but created on-the-fly during program execution, and is not described statically.

**Example #1:**
`squares = [x ** 2 for x in range(10)]` 

The snippet produces a ten-element list filled with squares of ten integer numbers starting from zero (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)

**Example #2:**
`twos = [2 ** i for i in range(8)]` 

The snippet creates an eight-element array containing the first eight powers of two (1, 2, 4, 8, 16, 32, 64, 128)

**Example #3:**
`odds = [x for x in squares if x % 2 != 0 ]` 

The snippet makes a list with only the odd elements of the `squares` list.

###### Two-dimensional arrays

Let's also assume that a **predefined symbol** named `EMPTY` designates an empty field on the chessboard.

So, if we want to create a list of lists representing the whole chessboard, it may be done in the following way:

`board = []  for i in range(8):      row = [EMPTY for i in range(8)]      board.append(row)` 

Note:
- the inner part of the loop creates a row consisting of eight elements (each of them equal to EMPTY) and appends it to the board list;
- the outer part repeats it eight times;
- in total, the `board` list consists of 64 elements (all equal to `EMPTY`)

This model perfectly mimics the real chessboard, which is in fact an eight-element list of elements, all being single rows. Let's summarize our observations:

- the elements of the rows are fields, eight of them per row;
- the elements of the chessboard are rows, eight of them per chessboard.

The `board` variable is now a **two-dimensional array**. It's also called, by analogy to algebraic terms, a **matrix**.

As list comprehensions can be **nested**, we can shorten the board creation in the following way:

`board = [[EMPTY for i in range(8)] for j in range(8)]` 

The inner part creates a row, and the outer part builds a list of rows.

Access to the selected field of the board requires two indices ‒ the first selects the row; the second ‒ the field number inside the row, which is de facto a column number.

###### Multidimensional nature of lists: advanced applications

Let's go deeper into the multidimensional nature of lists. To find any element of a two-dimensional list, you have to use two _coordinates_:
- a vertical one (row number)
- and a horizontal one (column number).

Imagine that you're developing a piece of software for an automatic weather station. The device records the air temperature on an hourly basis and does it throughout the month. This gives you a total of 24 × 31 = 744 values. Let's try to design a list capable of storing all these results.

First, you have to decide which data type would be adequate for this application. In this case, a `float` would be best, since this thermometer is able to measure the temperature with an accuracy of 0.1 ℃.

Then you take an arbitrary decision that the rows will record the readings every hour on the hour (so the row will have 24 elements) and each of the rows will be assigned to one day of the month (let's assume that each month has 31 days, so you need 31 rows). Here's the appropriate pair of comprehensions (`h` is for hour, `d` for day):

```python
temps = [[0.0 for h in range(24)] for d in range(31)]

```

The whole matrix is filled with zeros now. You can assume that it's updated automatically using special hardware agents. The thing you have to do is to wait for the matrix to be filled with measurements.

---

Now it's time to determine the monthly average noon temperature. Add up all 31 readings recorded at noon and divide the sum by 31. You can assume that the midnight temperature is stored first. Here's the relevant code:

```python
temps = [[0.0 for h in range(24)] for d in range(31)]
#
# The matrix is magically updated here.
#

total = 0.0

for day in temps:
    total += day[11]

average = total / 31

print("Average temperature at noon:", average)

```

Note: the `day` variable used by the `for` loop is not a scalar ‒ each pass through the `temps` matrix assigns it with the subsequent rows of the matrix; hence, it's a list. It has to be indexed with `11` to access the temperature value measured at noon.

---

Now find the highest temperature during the whole month ‒ see the code:

```python
temps = [[0.0 for h in range(24)] for d in range(31)]
#
# The matrix is magically updated here.
#

highest = -100.0

for day in temps:
    for temp in day:
        if temp > highest:
            highest = temp

print("The highest temperature was:", highest)

```

Note:
- the day variable iterates through all the rows in the temps matrix;
- the temp variable iterates through all the measurements taken in one day.

---

Now count the days when the temperature at noon was at least 20 ℃:

```python
temps = [[0.0 for h in range(24)] for d in range(31)]
#
# The matrix is magically updated here.
#

hot_days = 0

for day in temps:
    if day[11] > 20.0:
        hot_days += 1

print(hot_days, "days were hot.")

```

Python does not limit the depth of list-in-list inclusion. Here you can see an example of a three-dimensional array:

```python
rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]

```

Imagine a hotel. It's a huge hotel consisting of three buildings, 15 floors each. There are 20 rooms on each floor. For this, you need an array which can collect and process information on the occupied/free rooms.

First step ‒ the type of the array's elements. In this case, a Boolean value (`True`/`False`) would fit.

Step two ‒ calm analysis of the situation. Summarize the available information: three buildings, 15 floors, 20 rooms.

Now you can create the array:

```python
rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]

```

The first index (`0` through `2`) selects one of the buildings; the second (`0` through `14`) selects the floor, the third (`0` through `19`) selects the room number. All rooms are initially free.

Now you can book a room for two newlyweds: in the second building, on the tenth floor, room 14:

```python
rooms[1][9][13] = True

```

and release the second room on the fifth floor located in the first building:

```python
rooms[0][4][1] = False

```

Check if there are any vacancies on the 15th floor of the third building:

```python
vacancy = 0

for room_number in range(20):
    if not rooms[2][14][room_number]:
        vacancy += 1

```

The `vacancy` variable contains `0` if all the rooms are occupied, or the number of available rooms otherwise.

Key properties:
- denoted by square brackets: `[]` with its elements separated by commas `,`
- **multi-value**: Able to store more than one value
- **dynamic size**: You can grow or shrink it automatically
- **heterogeneous**: Allows different types inside (e.g.: numbers, strings, objects, even other lists, etc)
- **ordered**: Items are stored in sequence and have indexes
- **mutable**: You can modify it by interacting with any variable that points to it in memory

---

#### Error Types
- `AttributeError` happens when you try to use a property or method that doesn’t exist for an object. Example: `number = 42` then `number.append(5)`
- `IndexError` happens when you try to access a position in a list (or similar structure) that doesn’t exist. Example: `my_list = [10, 20, 30]` then `print(my_list[5])`
- `ModuleNotFoundError`
- `NameError` happens when you try to use a variable or function name that hasn’t been defined. Example: `print(score)`when `score`hasn't been defined yet.
- `SyntaxError`
- `TypeError` happens when you use a value of the wrong type for an operation. Example: `print("Age: " + 25)`
- `ValueError` happens when a function gets the right type of input, but the value doesn’t make sense. Example: `int("hello")` → `"hello"` is a string, but not a valid number.
- `ZeroDivisionError`
#### Exceptions
- `KeyboardInterrupt` happens when you manually stop a running Python program—usually by pressing `Ctrl+C`.

---
#### Cool things to keep in mind
- `print()` can handle octals and hexadecimals
- `0.4` can be written as `.4` and `4.0` can be written as `4.` because you can omit zero when it is the only digit in front of or after the decimal point
- `300000000` or `3 x 10⁸` scientific notation is written as `3e8` or `3E8` in Python. Ex.: `6.62607E-34`
    - Note: the exponent (the value after the E) has to be an integer; the base (the value in front of the E) may be either an integer or a float.
- `print('I\'m Monty Python.')` or `print("I'm Monty Python.")`
- `6 // 3` equals `2` (integer) because only when an integer is divided by an integer with `//` (integer/floor division) it results in an integer. Any regular divisions (`/`) or a floor division involving a float operand WILL result in a float because anything involving a float results in a float, even addition, subtraction, multiplication and exponentiation. Even an integer exponentiation may result in a float: `4 ** -1` equals `0.25`. However, for `//`, anything after the floating point becomes `0`. Ex.: `10 / 3` equals 3.333... but `10 // 3` equals `3`
- `%` (Remainder/Modulo) always results in a integer (or a float with `.0` if either operand is a float) because it results the remainder left after the integer division

| >OPERATION     | INT & INT      | INT & FLOAT     | FLOAT & INT      | FLOAT & FLOAT      |
| -------------- | -------------- | --------------- | ---------------- | ------------------ |
| Addition       | 1 + 1 = 2      | 1 + 1.0 = 2.0   | 1.5 + 1 = 2.5    | 1.5 + 1.0 = 2.5    |
| Subtraction    | 1 - 1 = 0      | 1 - 1.0 = 0.0   | 1.5 - 1 = 0.5    | 1.5 - 1.0 = 0.5    |
| Multiplication | 2 * 2 = 4      | 2 * 2.0 = 4.0   | 2.5 * 2 = 5.0    | 2.5 * 2.0 = 5.0    |
| Division       | 2 / 2 = 1.0    | 2 / 2.0 = 1.0   | 2.5 / 2 = 1.25   | 2.5 / 2.0 = 1.25   |
| Floor Division | 2 // 2 = 1     | 2 // 2.0 = 1.0  | 2.5 // 2 = 1.0   | 2.5 // 2.0 = 1.0   |
| Modulo         | 12 % 5 = 2     | 12 % 4.5 = 3.0  | 12.0 % 5 = 2.0   | 12.5 % 4.5 = 3.5   |
| Exponentiation | 4 ** 2 = 16    | 4 ** 2.0 = 16.0 | 4.5 ** 2 = 20.25 | 4.5 ** 2.0 = 20.25 |
| Extra          | 4 ** -1 = 0.25 |                 |                  |                    |
- `2 % 4` equals 2 because 2 - 4 * (2 // 4) = 2 - 4 * 0 = 2 - 0 = 2
- `2 % -4` equals -2 because 2 - (-4) * (2 // -4) = 2 - (-4) * -1.0 = 2 - 4 = -2
- if `a = 6` and `b = 3` then `a /= 2 * b` is `1.0` because `a = a / (2 * b)`
- `9 ** 0.5` evaluates the square root of 9
- `9 * 0.1` evaluates 10% of 9
- `9 * 1.1` evaluates 9 + 10% of 9
- `input()` can be used without an argument
- `2 == 2.` | `2. == 2` is True
- `while number:` is the same as `while number != 0:`
- `if number % 2:` is the same as `if number % 2 == 1:`
- Data Types and boolean values:
```Python
print(
f'''Integer: 1 - {bool(1)} | 0 - {bool(0)} | -1 - {bool(-1)}
Floating point: 1.0 - {bool(1.0)} | 0.0 - {bool(0.0)} | 0.1 - {bool(0.1)} | -1.0 - {bool(-1.0)}
String: 'Test' - {bool('Test')} | '' - {bool('')} | '0' - {bool('0')}
NoneType: None - {bool(None)}
List: [0, 0.0, '', False] - {bool([0, 0.0, '', False])} | [] - {bool([])}
Tuple: (0, 0.0, '', False) - {bool((0, 0.0, '', False))} | () - {bool(())}
Set: {{0, 0.0, '', False}} - {bool({0, 0.0, '', False})} | {{}} - {bool({})} | set() - {bool(set())}
''')

a = False
if a is not None:
    print(f"{a} is not NULL")
if a:
    print(f"{a} is not NULL, nor EMPTY (e.g.: '', 0, 0.0, False)")

```

- Python `==` vs `is`:
	- **`==`** → checks **value equality**
	- **`is`** → checks **object identity** (same memory location)
	- For booleans, always use `is` when checking against `True` or `False` **after using `bool()`**.
	- Never use `is` for numbers — only for singletons like `None`, `True`, `False`.

| Expression         | Result                    | Explanation                                                   |
| ------------------ | ------------------------- | ------------------------------------------------------------- |
| `0 == False`       | True                      | Values are equal (`False` is int subclass with value 0)       |
| `0 is False`       | False                     | Different objects/types (`int` vs `bool`)                     |
| `bool(0) == False` | True                      | Value equality, 0 converts to `False`                         |
| `bool(0) is False` | True                      | `bool()` returns the canonical `False` object → same identity |
| `None == None`     | True                      | Values are equal                                              |
| `None is None`     | True                      | Identity check → same object in memory                        |
| `len([]) == 0`     | True                      | `len([])` returns 0, equal to 0                               |
| `len([]) is 0`     | False (unsafe to rely on) | Different objects, `is` checks identity                       |
| `len([]) == False` | True                      | 0 is treated as False in boolean context                      |
| `len([]) is False` | False                     | different object types (`int` vs `bool`)                      |
| `len([]) is None`  | False                     | different object types                                        |
- `~4` equals `-5` because of two's complement: - (4 + 1)
- `17 >> 1` → `17 // 2` (**17** floor-divided by **2 to the power of 1**) → `8` (shifting to the right by one bit is the same as integer division by two)
- `17 << 2` → `17 * 4` (**17** multiplied by **2 to the power of 2**) → `68` (shifting to the left by two bits is the same as integer multiplication by four)
- `del numbers[1]` removes the 2nd element of a list while `del my_list` deletes the whole list
- An element with an index equal to -1 is **the last one in the list**.. Ex.: `numbers[-1]`
- `numbers.append(4)` adds the number `4` at the end of the list
- `numbers.insert(0, 222)` adds the number `222` to the index `0` of the list
- `numbers.sort()` sorts the list using timsort in ascending order
- `numbers.reverse()` reverses the list order, but without sorting it at all

> How to reverse the order of certain pairs of numbers in a list:
> ```python
> for i in range(length // 2):
>     my_list[i], my_list[length - i - 1] = my_list[length - i - 1], my_list[i]
>  
> print(my_list)
> ```
>  
>  Note:
>  - we've assigned the `length` variable with the current list's length (this makes our code a bit clearer and shorter)
>  - we've launched the `for` loop to run through its body `length // 2 times` (this works well for lists with both even and odd lengths, because when the list contains an odd number of elements, the middle one remains untouched)
>  - we've swapped the ith element (from the beginning of the list) with the one with an index equal to `(length - i - 1)` (from the end of the list); in our example, for `i` equal to `0` the `(length - i - 1)` gives `4`; for `i` equal to `1`, it gives `3` ‒ this is exactly what we needed.

- `my_list[start:end]` is called *slicing* which selects values from a list to work upon. `start` is the index of the first element **included in the slice**; `end` is the index of the first element **not included in the slice.** If you omit the `start` in your slice, it is assumed that you want to get a slice beginning at the element with index `0`. Similarly, if you omit the `end` in your slice, it is assumed that you want the slice to end at the element with the index `len(my_list)`.
- `my_list[start:]` means `my_list[start:len(my_list)]` so considering `my_list = [10, 8, 6, 4, 2]`, `new_list = my_list[3:]` equals `[4, 2]`
- `my_list[:end]` means `my_list[0:end]` so considering the above list `new_list = my_list[:3]` equals `[10, 8, 6]`
- `list_1[:]` selects an entire list. `my_list[1:3]` is more precise about where to start and end.
- `my_list[1:-1]` while `-1` represents the last element in a list
- `my_list[-1:1]` equals `[]`


---
#### How to read Python:
> ```Python
> var = 1
> print(var)
> var = var + 1
> print(var)
> ```
> - The first line of the snippet creates a new variable named `var` and assigns `1` to it.
> - The statement reads: assign a value of `1` to a variable named `var`.
> - We can say it shorter: assign `1` to `var`.
> - Some prefer to read such a statement as: `var` becomes `1`.
> - The third line **assigns the same variable with the new value taken** from the variable itself, summed with `1`. Seeing a record like that, a mathematician would probably protest ‒ no value may be equal to itself plus one. This is a contradiction. But Python treats the sign `=` not as *equal to*, but as *assign a value*.
> - Take the current value of the variable `var`, add `1` to it and store the result in the variable `var`.
> - In effect, the value of variable `var` has been incremented by one, which has nothing to do with comparing the variable with any value.

> `function_name(argument)`
> - First, Python checks if the name specified is legal (it browses its internal data in order to find an existing function of the name; if this search fails, Python aborts the code)
> - second, Python checks if the function's requirements for the number of arguments allows you to invoke the function in this way (e.g., if a specific function demands exactly two arguments, any invocation delivering only one argument will be considered erroneous, and will abort the code's execution)
> - third, Python leaves your code for a moment and jumps into the function you want to invoke; of course, it takes your argument(s) too and passes it/them to the function;
> - fourth, the function executes its code, causes the desired effect (if any), evaluates the desired result(s) (if any) and finishes its task;
> - finally, Python returns to your code (to the place just after the invocation) and resumes its execution.

> ```Python
> print("Tell me anything...")
> anything = input()
> print("Hmm...", anything, "... Really?") 
> ```
> It shows a very simple case of using the `input()` function.
> 
> Note:
> - The program **prompts the user to input some data** from the console (most likely using a keyboard, although it is also possible to input data using voice or image);
> - the `input()` function is invoked without arguments (this is the simplest way of using the function); the function will **switch the console to input mode**; you'll see a blinking cursor, and you'll be able to input some keystrokes, finishing off by hitting the _Enter_ key; all the inputted data will be **sent to your program** through the function's result;
> - note: you need to assign the result to a variable; this is crucial ‒ missing out this step will cause the entered data to be lost;
> - then we use the `print()` function to output the data we get, with some additional remarks.

> ```Python
> anything = input("Tell me anything...")
> print("Hmm...", anything, "...Really?") 
> ```
> Note:
> - the `input(`) function is invoked with one argument ‒ it's a string containing a message;
> - the message will be displayed on the console before the user is given an opportunity to enter anything;
> - `input()` will then do its job.
> This variant of the `input()` invocation simplifies the code and makes it clearer.

> ``` python
> if true_or_not:
>     do_this_if_true 
> ```
> 
> This conditional statement consists of the following, strictly necessary, elements in this and this order only:
> 
> - the `if` keyword;
> - one or more white spaces;
> - an expression (a question or an answer) whose value will be interpreted solely in terms of `True` (when its value is non-zero) and `False` (when it is equal to zero);
> - a **colon** followed by a newline;
> - an **indented** instruction or set of instructions (at least one instruction is absolutely required); the **indentation** may be achieved in two ways – by inserting a particular number of spaces (the recommendation is to use **four spaces of indentation**), or by using the _tab_ character; note: if there is more than one instruction in the indented part, the indentation should be the same in all lines; even though it may look the same if you use tabs mixed with spaces, it's important to make all indentations **exactly the same** – Python 3 **does not allow the mixing of spaces and tabs** for indentation.
> 
> How does that statement work?
> 
> - If the `true_or_not` expression **represents the truth** (i.e., its value is not equal to zero), **the indented statement(s) will be executed**;
> - if the `true_or_not` expression **does not represent the truth** (i.e., its value is equal to zero), **the indented statement(s) will be omitted** (ignored), and the next executed instruction will be the one after the original indentation level.
> 
> In real life, we often express a desire:
> 
> _if the weather is good, we'll go for a walk_
> _then, we'll have lunch_
> 
> As you can see, having lunch is **not a conditional activity** and doesn't depend on the weather.
> 
> Knowing what conditions influence our behavior, and assuming that we have the parameterless functions `go_for_a_walk()` and `have_lunch()`, we can write the following snippet:
> ```python
> if the_weather_is_good:
>     go_for_a_walk()
> have_lunch()
> ```

> If a certain sleepless Python developer falls asleep when he or she counts 120 sheep, and the sleep-inducing procedure may be implemented as a special function named `sleep_and_dream()`, the whole code takes the following shape:
> ```python
> if sheep_counter >= 120: # Evaluate a test expression
>     sleep_and_dream() # Execute if test expression is True` 
> ```
> You can read it as: if `sheep_counter` is greater than or equal to 120, then fall asleep and dream (i.e., execute the `sleep_and_dream function`.)

> We can say, for example: _If the weather is good, we will go for a walk, otherwise we will go to a theater_.
>
> Now we know what we'll do **if the conditions are met**, and we know what we'll do **if not everything goes our way**. In other words, we have a "Plan B".
> 
> Python allows us to express such alternative plans. This is done with a second, slightly more complex form of the conditional statement, the _if-else_ statement:
> ```python
> if true_or_false_condition:
>     perform_if_condition_true
> else:
>     perform_if_condition_false
> ```
> Thus, there is a new word: `else` – this is a **keyword**.
> 
> The part of the code which begins with `else` says what to do if the condition specified for the `if` is not met (note the **colon** after the word).
> 
> The _if-else_ execution goes as follows:
> 
> - if the condition evaluates to **True** (its value is not equal to zero), the `perform_if_condition_true` statement is executed, and the conditional statement comes to an end;
> - if the condition evaluates to **False** (it is equal to zero), the `perform_if_condition_false` statement is executed, and the conditional statement comes to an end.
>
> By using this form of conditional statement, we can describe our plans as follows:
> 
> ```python
> if the_weather_is_good:
>     go_for_a_walk()
> else:
>     go_to_a_theater()
> have_lunch()
> ```
> If the weather is good, we'll go for a walk. Otherwise, we'll go to a theater. No matter if the weather is good or bad, we'll have lunch afterwards (after the walk or after going to the theater).

> Read what we have planned for this Sunday. If the weather is fine, we'll go for a walk. If we find a nice restaurant, we'll have lunch there. Otherwise, we'll eat a sandwich. If the weather is poor, we'll go to the theater. If there are no tickets, we'll go shopping in the nearest mall.
>
> Let's write the same in Python. Consider carefully the code here:
> ```python
> if the_weather_is_good:
>     if nice_restaurant_is_found:
>         have_lunch()
>     else:
>         eat_a_sandwich()
> else:
>     if tickets_are_available:
>         go_to_the_theater()
>     else:
>         go_shopping()
> ```

> `elif` is used to **check more than just one condition**, and to **stop** when the first statement which is true is found.
> 
> Our next example resembles nesting, but the similarities are very slight. Again, we'll change our plans and express them as follows: If the weather is fine, we'll go for a walk, otherwise if we get tickets, we'll go to the theater, otherwise if there are free tables at the restaurant, we'll go for lunch; if all else fails, we'll stay home and play chess.
> 
> Have you noticed how many times we've used the word _otherwise_? This is the stage where the `elif` keyword plays its role.
> 
> Let's write the same scenario using Python:
> 
> ```python
> if the_weather_is_good:
>     go_for_a_walk()
> elif tickets_are_available:
>     go_to_the_theater()
> elif table_is_available:
>     go_for_lunch()
> else:
>     play_chess_at_home()
> ```

> Actually, the for loop is designed to do more complicated tasks – **it can "browse" large collections of data item by item**. We'll show you how to do that soon, but right now we're going to present a simpler variant of its application.
> 
> Take a look at the snippet:
> 
> ```python
> for i in range(100):
>     # do_something()
>     pass
> ```
> 
> There are some new elements. Let us tell you about them:
> 
> - the _for_ keyword opens the `for` loop; note – there's no condition after it; you don't have to think about conditions, as they're checked internally, without any intervention;
> - any variable after the _for_ keyword is the **control variable** of the loop; it counts the loop's turns, and does it automatically;
> - the _in_ keyword introduces a syntax element describing the range of possible values being assigned to the control variable;
> - the `range()` function (this is a very special function) is responsible for generating all the desired values of the control variable; in our example, the function will create (we can even say that it will **feed** the loop with) subsequent values from the following set: 0, 1, 2 .. 97, 98, 99; note: in this case, the `range()` function starts its job from 0 and finishes it one step (one integer number) before the value of its argument;
> - note the _pass_ keyword inside the loop body – it does nothing at all; it's an **empty instruction** – we put it here because the `for` loop's syntax demands at least one instruction inside the body (by the way – `if`, `elif`, `else` and `while` express the same thing)

> Let's create a variable called numbers; it's assigned with not just one number, but is filled with a list consisting of five values (note: the **list starts with an open square bracket and ends with a closed square bracket**; the space between the brackets is filled with five numbers separated by commas).
> 
> ```
> numbers = [10, 5, 7, 2, 1] 
> ```
> 
> Let's say the same thing using adequate terminology: **numbers is a list consisting of five values, all of them numbers**. We can also say that this statement creates a list of length equal to five (as in there are five elements inside it).

> The `for` loop has a special variant that can **process lists** very effectively ‒ let's take a look at that.
> 
> ```python
> my_list = [10, 1, 8, 3, 5]
> total = 0
> 
> for i in range(len(my_list)):
>     total += my_list[i]
> 
> print(total)
> 
> ```
> 
> Let's assume that you want to **calculate the sum of all the values stored in the `my_list` list**.
> 
> You need a variable whose sum will be stored and initially assigned a value of `0` ‒ its name will be `total`. (Note: we're not going to name it `sum` as Python uses the same name for one of its built-in functions: `sum()`. **Using the same name would generally be considered bad practice**.) Then you add to it all the elements of the list using the `for` loop. Take a look at the snippet in the editor.
> 
> Let's comment on this example:
> 
> - the list is assigned a sequence of five integer values;
> - the i variable takes the values `0`, `1`,` 2`, `3`, and `4`, and then it indexes the list, selecting the subsequent elements: the first, second, third, fourth and fifth;
> - each of these elements is added together by the `+=` operator to the `total` variable, giving the final result at the end of the loop;
> - note the way in which the `len()` function has been employed ‒ it makes the code independent of any possible changes in the list's contents.

> But the `for` loop can do much more. It can hide all the actions connected to the list's indexing, and deliver all the list's elements in a handy way.
> 
> This modified snippet shows how it works:
> 
> ```python
> my_list = [10, 1, 8, 3, 5]
> total = 0
> 
> for i in my_list:
>     total += i
> 
> print(total)
> 
> ```
> 
> What happens here?
> 
> - the `for` instruction specifies the variable used to browse the list (`i` here) followed by the `in` keyword and the name of the list being processed (`my_list` here)
> - the `i` variable is assigned the values of all the subsequent list's elements, and the process occurs as many times as there are elements in the list;
> - this means that you use the `i` variable as a copy of the elements' values, and you don't need to use indices;
> - the `len()` function is not needed here, either.

> Now you can easily **swap** the list's elements to **reverse their order:**
> 
> ```python
> my_list = [10, 1, 8, 3, 5]
> 
> my_list[0], my_list[4] = my_list[4], my_list[0]
> my_list[1], my_list[3] = my_list[3], my_list[1]
> 
> print(my_list)
> ```
> 
> Run the snippet. Its output should look like this:
> 
> ```Output
> [5, 3, 8, 1, 10]
> ```
> 
> It looks fine with five elements.
> 
> Will it still be acceptable with a list containing 100 elements? No, it won't.
> 
> Can you use the `for` loop to do the same thing automatically, irrespective of the list's length? Yes, you can.
> 
> This is how we've done it:
> 
> ```python
> for i in range(length // 2):
>     my_list[i], my_list[length - i - 1] = my_list[length - i - 1], my_list[i]
> 
> print(my_list)
> ```
> 
> Note:
> 
> - we've assigned the `length` variable with the current list's length (this makes our code a bit clearer and shorter)
> - we've launched the `for` loop to run through its body `length // 2 times` (this works well for lists with both even and odd lengths, because when the list contains an odd number of elements, the middle one remains untouched)
> - we've swapped the ith element (from the beginning of the list) with the one with an index equal to `(length - i - 1)` (from the end of the list); in our example, for `i` equal to `0` the `(length - i - 1)` gives `4`; for `i` equal to `1`, it gives `3` ‒ this is exactly what we needed.

> ```python
> list_1 = [1]
> list_2 = list_1
> list_1[0] = 2
> print(list_2)
> ```
> 
> The program:
> - creates a one-element list named `list_1`;
> - assigns it to a new list named `list_2`;
> - changes the only element of `list_1`;
> - prints out `list_2`.
> 
> The surprising part is the fact that the program will output: `[2]`, not `[1]`, which seems to be the obvious solution.
> 
> Lists (and many other complex Python entities) are stored in different ways than ordinary (scalar) variables.
> 
> You could say that:
> - the name of an ordinary variable is the **name of its content**;
> - the name of a list is the name of a **memory location where the list is stored**.
> 
> Read these two lines once more ‒ the difference is essential for understanding what we are going to talk about next.
> 
> The assignment: `list_2 = list_1` copies the name of the array, not its contents. In effect, the two names (`list_1` and `list_2`) identify the same location in the computer memory. Modifying one of them affects the other, and vice versa.
> 
> How do you cope with that?

> Python offers two very powerful operators, able to **look through the list in order to check whether a specific value is stored inside the list or not**.
> 
> These operators are:
> 
> ```python
> elem in my_list
> elem not in my_list
> ```
> 
> The first of them (`in`) checks if a given element (its left argument) is currently stored somewhere inside the list (the right argument) ‒ the operator returns `True` in this case.
> 
> The second (`not in`) checks if a given element (its left argument) is absent in a list ‒ the operator returns `True` in this case.

> Look at the code below:
> 
> ```python
> row = []
> 
> for i in range(8):
>     row.append(WHITE_PAWN)
> 
> ```
> 
> It builds a list containing eight elements representing the second row of the chessboard ‒ the one filled with pawns (assume that `WHITE_PAWN `is a **predefined symbol** representing a white pawn).

> Take a look at the snippet:
> 
> ```python
> row = [WHITE_PAWN for i in range(8)]
> 
> ```
> 
> The part of the code placed inside the brackets specifies:
> 
> - the data to be used to fill the list (`WHITE_PAWN`)
> - the clause specifying how many times the data occurs inside the list (`for i in range(8)`)

> You can use **nested lists** in Python to create **matrices** (i.e., two-dimensional lists). For example:
> ```python
> # A four-column/four-row table ‒ a two dimensional array (4x4)
> 
> table = [[":(", ":)", ":(", ":)"],
>          [":)", ":(", ":)", ":)"],
>          [":(", ":)", ":)", ":("],
>          [":)", ":)", ":)", ":("]]
> 
> print(table)
> print(table[0][0])  # outputs: ':('
> print(table[0][3])  # outputs: ':)'
> 
> ```
> 
> You can nest as many lists in lists as you want, thereby creating n-dimensional lists, e.g., three-, four- or even sixty-four-dimensional arrays. For example:
> ```python
> # Cube - a three-dimensional array (3x3x3)
> 
> cube = [[[':(', 'x', 'x'],
>          [':)', 'x', 'x'],
>          [':(', 'x', 'x']],
> 
>         [[':)', 'x', 'x'],
>          [':(', 'x', 'x'],
>          [':)', 'x', 'x']],
> 
>         [[':(', 'x', 'x'],
>          [':)', 'x', 'x'],
>          [':)', 'x', 'x']]]
> 
> print(cube)
> print(cube[0][0][0])  # outputs: ':('
> print(cube[2][2][0])  # outputs: ':)'
> 
> ```

> You need to **define** it. The word _define_ is significant here.
> 
> This is what the simplest function definition looks like:
> 
> ```
> def function_name():
>     function_body 
> ```
> 
> - It always starts with the **keyword `def`** (for _define_)
> - next after `def` goes the **name of the function** (the rules for naming functions are exactly the same as for naming variables)
> - after the function name, there's a place for a pair of **parentheses** (they contain nothing here, but that will change soon)
> - the line has to be ended with a **colon**;
> - the line directly after `def` begins the **function body** ‒ a couple (at least one) of necessarily **nested instructions**, which will be executed every time the function is invoked; note: the **function ends where the nesting ends**, so you have to be careful.
> 
> **IMPORTANT**: Python reads the function's definitions and remembers them, but won't launch any of them without your permission, so make sure to insert the function's invocation in the code.
> - when you **invoke** a function, Python remembers the place where it happened and _jumps_ into the invoked function;
> - the body of the function is then **executed**;
> - reaching the end of the function forces Python to **return** to the place directly after the point of invocation.

> Look at the function invocation below:
> 
> ```python
> adding(3, c = 1, b = 2)
> 
> ```
> 
> Let's analyze it:
> - the argument (`3`) for the `a` parameter is passed using the positional way;
> - the arguments for `c` and `b` are specified as keyword ones.
> 
> This is what you'll see in the console:
> 
> ```Output
> 3 + 2 + 1 = 6
> ```

---
## Examples

```python
# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))

# Choose the larger number
if number1 > number2:
    larger_number = number1
else:
    larger_number = number2

# Print the result
print("The larger number is:", larger_number)

```

```python
# Read three numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))

# We temporarily assume that the first number
# is the largest one.
# We will verify this soon.
largest_number = number1

# We check if the second number is larger than the current largest_number
# and update the largest_number if needed.
if number2 > largest_number:
    largest_number = number2

# We check if the third number is larger than the current largest_number
# and update the largest_number if needed.
if number3 > largest_number:
    largest_number = number3

# Print the result
print("The largest number is:", largest_number)

```

```python
# Store the current largest number here.
largest_number = -999999999

# Input the first value.
number = int(input("Enter a number or type -1 to stop: "))

# If the number is not equal to -1, continue.
while number != -1:
    # Is number larger than largest_number?
    if number > largest_number:
        # Yes, update largest_number.
        largest_number = number
    # Input the next number.
    number = int(input("Enter a number or type -1 to stop: "))

# Print the largest number.
print("The largest number is:", largest_number)

```

```python
largest_number = -99999999
counter = 0

while True:
    number = int(input("Enter a number or type -1 to end the program: "))
    if number == -1:
        break
    counter += 1
    if number > largest_number:
        largest_number = number

if counter != 0:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")

```

```python
largest_number = -99999999
counter = 0

number = int(input("Enter a number or type -1 to end program: "))

while number != -1:
    if number == -1:
        continue
    counter += 1

    if number > largest_number:
        largest_number = number
    number = int(input("Enter a number or type -1 to end the program: "))

if counter:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")

```

---

```python
# A program that reads a sequence of numbers
# and counts how many numbers are even and how many are odd.
# The program terminates when zero is entered.

odd_numbers = 0
even_numbers = 0

# Read the first number.
number = int(input("Enter a number or type 0 to stop: "))

# 0 terminates execution.
while number != 0:
    # Check if the number is odd.
    if number % 2 == 1:
        # Increase the odd_numbers counter.
        odd_numbers += 1
    else:
        # Increase the even_numbers counter.
        even_numbers += 1
    # Read the next number.
    number = int(input("Enter a number or type 0 to stop: "))

# Print results.
print("Odd numbers count:", odd_numbers)
print("Even numbers count:", even_numbers)

```

```python
counter = 5
while counter != 0:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)

```

```python
counter = 5
while counter:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)

```

```python
i = 1
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)
```

```python
i = 5
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)
```

```python
for i in range(5):
    print(i)
else:
    print("else:", i)
```

```python
i = 111
for i in range(2, 1):
    print(i)
else:
    print("else:", i)
```

```python
n = 3
 
while n > 0:
    print(n + 1)
    n -= 1
else:
    print(n)
```

```python
n = range(4)
 
for num in n:
    print(num - 1)
else:
    print(num)
```

```python
my_list = []  # Creating an empty list.

for i in range(5):
    my_list.append(i + 1)

print(my_list)
```

```python
my_list = []  # Creating an empty list.

for i in range(5):
    my_list.insert(0, i + 1)

print(my_list)
```

---

```python
my_list = [8, 10, 6, 2, 4]  # list to sort

for i in range(len(my_list) - 1):  # we need (5 - 1) comparisons
    if my_list[i] > my_list[i + 1]:  # compare adjacent elements
        my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]  # If we end up here, we have to swap the elements.

```

```python
my_list = [8, 10, 6, 2, 4]  # list to sort
swapped = True  # It's a little fake, we need it to enter the while loop.

while swapped:
    swapped = False  # no swaps so far
    for i in range(len(my_list) - 1):
        if my_list[i] > my_list[i + 1]:
            swapped = True  # a swap occurred!
            my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]

print(my_list)

```

```python
my_list = []
swapped = True
num = int(input("How many elements do you want to sort: "))

for i in range(num):
    val = float(input("Enter a list element: "))
    my_list.append(val)

while swapped:
    swapped = False
    for i in range(len(my_list) - 1):
        if my_list[i] > my_list[i + 1]:
            swapped = True
            my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]

print("\nSorted:")
print(my_list)

```

--- 

```python
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in range(1, len(my_list)):
    if my_list[i] > largest:
        largest = my_list[i]

print(largest)
```

The concept is rather simple ‒ we temporarily assume that the first element is the largest one, and check the hypothesis against all the remaining elements in the list.

The code outputs `17` (as expected).

The code may be rewritten to make use of the newly introduced form of the `for` loop:

```python
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in my_list:
    if i > largest:
        largest = i

print(largest)

```

The program above performs one unnecessary comparison, when the first element is compared with itself, but this isn't a problem at all.

The code outputs `17`, too (nothing unusual).

If you need to save computer power, you can use a slice:

```python
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in my_list[1:]:
    if i > largest:
        largest = i

print(largest)
```

---

Now let's find the location of a given element inside a list:

```python
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
to_find = 5
found = False

for i in range(len(my_list)):
    found = my_list[i] == to_find
    if found:
        break

if found:
    print("Element found at index", i)
else:
    print("absent")

```

Note:

- the target value is stored in the `to_find` variable;
- the current status of the search is stored in the `found` variable (`True`/`False`)
- when `found` becomes `True`, the `for` loop is exited.

---

Let's assume that you've chosen the following numbers in the lottery: `3`, `7`, `11`, `42`, `34`, `49`.

The numbers that have been drawn are: `5`, `11`, `9`, `42`, `3`, `49`.

The question is: how many numbers have you hit?

This program will give you the answer:

```python
drawn = [5, 11, 9, 42, 3, 49]
bets = [3, 7, 11, 42, 34, 49]
hits = 0

for number in bets:
    if number in drawn:
        hits += 1

print(hits)

```

Note:

- the `drawn` list stores all the drawn numbers;
- the `bets` list stores your bets;
- the `hits` variable counts your hits.

The program output is: `4`.