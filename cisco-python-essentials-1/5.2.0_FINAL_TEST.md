Final Test

1. What is the output of the following snippet?

```python
my_list = [1, 2]

for v in range(2):
    my_list.insert(-1, my_list[v])

print(my_list)

```

- [ ] `[1, 2, 2, 2]`
- [ ] `[2, 1, 1, 2]`
- [ ] `[1, 2, 1, 2]`
- [ ] `[1, 1, 1, 2]`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: Let’s analyze the program:
	- Line 1: the _my_list_ list is created. The list stores the following contents: _[1, 2]_
	- Line 3: the _range()_ function generates a sequence of two numbers (_0_ and _1_), and the _for_ loop iterates over that sequence. The _v_ variable takes the value of the number inside the sequence on each iteration, and the loop continues until the last number in the sequence is reached. The body of the loop is entered and the `my_list.insert(-1, my_list[v])` operation is performed two times.
	- Line 4: after the first _for_ loop iteration (when _v = 0_), the _[1, 2]_ list is updated – the _insert()_ method inserts a new element to the list (_v = 0_, so _my_list[v] = 1_) at the specified index (-1). The _my_list_ list after the first _for_ loop iteration has the following contents: _[1, 1, 2]_. After the second for loop iteration (when _v = 1_), the _[1, 2, 3]_ list is updated for the second time – the _insert()_ method inserts another new element to the list (_v = 1_, so _my_list[v] = 1_) at the specified index (_-1_). The _my_list_ list after the second _for_ loop iteration contains the following contents: _[1, 1, 1, 2]_.
	- Line 6: the _print()_ function prints the list contents to the screen.
</details>

---

2. The meaning of a _positional argument_ is determined by:
- [ ] its position within the argument list
- [ ] its value
- [ ] its connection with existing variables
- [ ] the argument’s name specified along with its value

<details>
  <summary>Answer</summary>

  - Answer: its position within the argument list
  - Reason: Positional arguments can be called by their position in a function call, and therefore must be included in the correct order.
</details>

---

3. Which of the following sentences are **true** about the code? (Select **two** answers)

```python
nums = [1, 2, 3]
vals = nums

```

- [ ] `nums` and `vals` are different names of the same list
- [ ] `nums` has the same length as `vals`
- [ ] `vals` is longer than `nums`
- [ ] `nums` and `vals` are different lists

<details>
  <summary>Answers</summary>

  - Answers: `nums` and `vals` are different names of the same list AND `nums` has the same length as `vals`
  - Reason: Assigning _nums_ to _vals_ creates a situation in which the same list (i.e. _[1, 2, 3]_) has two different names. Giving a new name to an existing list, in our case _vals_ to nums, is called **aliasing**. And since _nums_ and _vals_ are two different names that refer to the same object, they also have the same length (_3_).
</details>

---

4. An operator able to check whether two values are **not equal** is coded as:
- [ ] `<>`
- [ ] `!=`
- [ ] `not ==`
- [ ] `=/=`

<details>
  <summary>Answer</summary>

  - Answer: `!=`
  - Reason: The _!=_ operator checks whether two values are not equal. For example, the following expression _1 != 2_ will evaluate as _True_.
</details>

---

5. The following snippet:

```python
def function_1(a):
    return None


def function_2(a):
    return function_1(a) * function_1(a)


print(function_2(2))

```

- [ ] will output `16`
- [ ] will cause a runtime error
- [ ] will output `4`
- [ ] will output `2`

<details>
  <summary>Answer</summary>

  - Answer: will cause a runtime error
  - Reason: The _None_ object has no arithmetic operators defined – the program will raise the _TypeError_ exception, because the _NoneType_ type cannot be the _*_ operator’s operand.
</details>

---

6. The result of the following division:

`1 // 2`

- [ ] is equal to `0.0`
- [ ] cannot be predicted
- [ ] is equal to `0`
- [ ] is equal to `0.5`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: The _//_ operator divides two numbers and rounds the result down to the nearest integer number. Since _1_ divided by _2_ is 0.5, the resulting number is rounded down to _0_.
</details>

---

7. The following snippet:

```python
def func(a, b):
    return b ** a


print(func(b=2, 2))

```

- [ ] will output 2
- [ ] will output 4
- [ ] is erroneous
- [ ] will output None

<details>
  <summary>Answer</summary>

  - Answer: is erroneous
  - Reason: The program will raise the _SyntaxError_, because the positional argument in the function call (_2_) follows the keyword argument (_b=2_). Changing the order of the arguments in the _func()_ function invocation (i.e. _func(2, b=2)_) fixes the issue, in which case the program would output _4_ as the result.
</details>

---

8. What value will be assigned to the `x` variable?

```python
z = 0
y = 10
x = y < z and z > y or y < z and z < y

```

- [ ] `1`
- [ ] `True`
- [ ] `0`
- [ ] `False`

<details>
  <summary>Answer</summary>

  - Answer: `False`
  - Reason: Let’s analyze the example:
	- _0_ is assigned to _z_, and _10_ is assigned to _y_,
	- the result of the following evaluation `y < z and z > y or y < z and z < y` is assigned to _x_:
	- _y < z_ evaluates to False,
	- _z > y_ evaluates to False,
	- _y < z_ evaluates to False again,
	- and _z < y_ evaluates to True.
	- And now: False **and** False is False; False **or** False is False; and finally False **and** True is False.
</details>

---

9. Which of the following variable names are **illegal** and will cause the SyntaxError exception? (Select **two** answers)

- [ ] `In`
- [ ] `for`
- [ ] `print`
- [ ] `in`

<details>
  <summary>Answer</summary>

  - Answer: `for` AND ìn`
  - Reason: The _in_ and _for_ names are Python reserved words (keywords). These cannot be used as variable names. Note that the name _print_ is not a Python reserved word and can be used as a variable name, in which case it will shadow the Python built-in function, _print()_.
</details>

---

10. What is the output of the following snippet?

```python
my_list =  [x * x for x in range(5)]


def fun(lst):
    del lst[lst[2]]
    return lst


print(fun(my_list))

```

- [ ] `[0, 1, 4, 9]`
- [ ] `[0, 1, 9, 16]`
- [ ] `[1, 4, 9, 16]`
- [ ] `[0, 1, 4, 16]`

<details>
  <summary>Answer</summary>

  - Answer: `[0, 1, 4, 9]`
  - Reason: Let’s analyze the example:
	- Line 1: The list comprehension is used to create the following list: _[0, 1, 4, 9, 16]_, and assign it to the _my_list_ variable,
	- Lines 4-6: The _fun()_ function is defined, which takes a list (_lst_) as its argument. In the body of the function, the _del_ instruction deletes a specified element of the list, and returns the updated list,
	- Line 9: The _print()_ function takes the _fun()_ function as its argument, and prints the returned value to the screen. The _fun()_ function takes the _my_list_ list as its argument and processes it – the _del_ instruction deletes the fourth element of the list (_my_list[2]_ is _4_).
</details>