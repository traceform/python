Final Test

1. What is the output of the following snippet?

```python
my_list = [1, 2]

for v in range(2):
    my_list.insert(-1, my_list[v])

print(my_list)

```

- [ ] `[1, 2, 2, 2]`
- [ ] `[2, 1, 1, 2]`
- [ ] `[1, 2, 1, 2]`
- [ ] `[1, 1, 1, 2]`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: Let’s analyze the program:
	- Line 1: the _my_list_ list is created. The list stores the following contents: _[1, 2]_
	- Line 3: the _range()_ function generates a sequence of two numbers (_0_ and _1_), and the _for_ loop iterates over that sequence. The _v_ variable takes the value of the number inside the sequence on each iteration, and the loop continues until the last number in the sequence is reached. The body of the loop is entered and the `my_list.insert(-1, my_list[v])` operation is performed two times.
	- Line 4: after the first _for_ loop iteration (when _v = 0_), the _[1, 2]_ list is updated – the _insert()_ method inserts a new element to the list (_v = 0_, so _my_list[v] = 1_) at the specified index (-1). The _my_list_ list after the first _for_ loop iteration has the following contents: _[1, 1, 2]_. After the second for loop iteration (when _v = 1_), the _[1, 2, 3]_ list is updated for the second time – the _insert()_ method inserts another new element to the list (_v = 1_, so _my_list[v] = 1_) at the specified index (_-1_). The _my_list_ list after the second _for_ loop iteration contains the following contents: _[1, 1, 1, 2]_.
	- Line 6: the _print()_ function prints the list contents to the screen.
</details>

---

2. The meaning of a _positional argument_ is determined by:
- [ ] its position within the argument list
- [ ] its value
- [ ] its connection with existing variables
- [ ] the argument’s name specified along with its value

<details>
  <summary>Answer</summary>

  - Answer: its position within the argument list
  - Reason: Positional arguments can be called by their position in a function call, and therefore must be included in the correct order.
</details>

---

3. Which of the following sentences are **true** about the code? (Select **two** answers)

```python
nums = [1, 2, 3]
vals = nums

```

- [ ] `nums` and `vals` are different names of the same list
- [ ] `nums` has the same length as `vals`
- [ ] `vals` is longer than `nums`
- [ ] `nums` and `vals` are different lists

<details>
  <summary>Answers</summary>

  - Answers: `nums` and `vals` are different names of the same list AND `nums` has the same length as `vals`
  - Reason: Assigning _nums_ to _vals_ creates a situation in which the same list (i.e. _[1, 2, 3]_) has two different names. Giving a new name to an existing list, in our case _vals_ to nums, is called **aliasing**. And since _nums_ and _vals_ are two different names that refer to the same object, they also have the same length (_3_).
</details>

---

4. An operator able to check whether two values are **not equal** is coded as:
- [ ] `<>`
- [ ] `!=`
- [ ] `not ==`
- [ ] `=/=`

<details>
  <summary>Answer</summary>

  - Answer: `!=`
  - Reason: The _!=_ operator checks whether two values are not equal. For example, the following expression _1 != 2_ will evaluate as _True_.
</details>

---

5. The following snippet:

```python
def function_1(a):
    return None


def function_2(a):
    return function_1(a) * function_1(a)


print(function_2(2))

```

- [ ] will output `16`
- [ ] will cause a runtime error
- [ ] will output `4`
- [ ] will output `2`

<details>
  <summary>Answer</summary>

  - Answer: will cause a runtime error
  - Reason: The _None_ object has no arithmetic operators defined – the program will raise the _TypeError_ exception, because the _NoneType_ type cannot be the _*_ operator’s operand.
</details>

---

6. The result of the following division:

`1 // 2`

- [ ] is equal to `0.0`
- [ ] cannot be predicted
- [ ] is equal to `0`
- [ ] is equal to `0.5`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: The _//_ operator divides two numbers and rounds the result down to the nearest integer number. Since _1_ divided by _2_ is 0.5, the resulting number is rounded down to _0_.
</details>

---

7. The following snippet:

```python
def func(a, b):
    return b ** a


print(func(b=2, 2))

```

- [ ] will output 2
- [ ] will output 4
- [ ] is erroneous
- [ ] will output None

<details>
  <summary>Answer</summary>

  - Answer: is erroneous
  - Reason: The program will raise the _SyntaxError_, because the positional argument in the function call (_2_) follows the keyword argument (_b=2_). Changing the order of the arguments in the _func()_ function invocation (i.e. _func(2, b=2)_) fixes the issue, in which case the program would output _4_ as the result.
</details>

---

8. What value will be assigned to the `x` variable?

```python
z = 0
y = 10
x = y < z and z > y or y < z and z < y

```

- [ ] `1`
- [ ] `True`
- [ ] `0`
- [ ] `False`

<details>
  <summary>Answer</summary>

  - Answer: `False`
  - Reason: Let’s analyze the example:
	- _0_ is assigned to _z_, and _10_ is assigned to _y_,
	- the result of the following evaluation `y < z and z > y or y < z and z < y` is assigned to _x_:
	- _y < z_ evaluates to False,
	- _z > y_ evaluates to False,
	- _y < z_ evaluates to False again,
	- and _z < y_ evaluates to True.
	- And now: False **and** False is False; False **or** False is False; and finally False **and** True is False.
</details>

---

9. Which of the following variable names are **illegal** and will cause the SyntaxError exception? (Select **two** answers)

- [ ] `In`
- [ ] `for`
- [ ] `print`
- [ ] `in`

<details>
  <summary>Answer</summary>

  - Answer: `for` AND ìn`
  - Reason: The _in_ and _for_ names are Python reserved words (keywords). These cannot be used as variable names. Note that the name _print_ is not a Python reserved word and can be used as a variable name, in which case it will shadow the Python built-in function, _print()_.
</details>

---

10. What is the output of the following snippet?

```python
my_list =  [x * x for x in range(5)]


def fun(lst):
    del lst[lst[2]]
    return lst


print(fun(my_list))

```

- [ ] `[0, 1, 4, 9]`
- [ ] `[0, 1, 9, 16]`
- [ ] `[1, 4, 9, 16]`
- [ ] `[0, 1, 4, 16]`

<details>
  <summary>Answer</summary>

  - Answer: `[0, 1, 4, 9]`
  - Reason: Let’s analyze the example:
	- Line 1: The list comprehension is used to create the following list: _[0, 1, 4, 9, 16]_, and assign it to the _my_list_ variable,
	- Lines 4-6: The _fun()_ function is defined, which takes a list (_lst_) as its argument. In the body of the function, the _del_ instruction deletes a specified element of the list, and returns the updated list,
	- Line 9: The _print()_ function takes the _fun()_ function as its argument, and prints the returned value to the screen. The _fun()_ function takes the _my_list_ list as its argument and processes it – the _del_ instruction deletes the fourth element of the list (_my_list[2]_ is _4_).
</details>

---

11. What is the output of the following piece of code?

```python
x = 1
y = 2
x, y, z = x, x, y
z, y, z = x, y, z

print(x, y, z)

```

- [ ] `1 2 1`
- [ ] `1 1 2`
- [ ] `1 2 2`
- [ ] `2 1 2`

<details>
  <summary>Answer</summary>

  - Answer: `1 1 2`
  - Reason: Let’s analyze the example:
	- _x = 1_ and _y = 2_
	- as a result of the first multiple variable assignment (Line 3), **_x = 1_**, _y = 1_, and _z = 2_
	- as a result of the second multiple variable assignment (Line 4), _z = x = 1_, **_y = y = 1_**, and **_z = z = 2_** (because the original assignment from the previous line now overwrites the first _z_ assignment from the current line)
	- the result printed to the screen is therefore `1 1 2`
</details>

---

12. What will be the output of the following snippet?

```python
a = 1
b = 0
a = a ^ b
b = a ^ b
a = a ^ b

print(a, b)

```

- [ ] `0 0`
- [ ] `0 1`
- [ ] `1 0`
- [ ] `1 1`

<details>
  <summary>Answer</summary>

  - Answer: `0 1`
  - Reason: Let’s analyze the code line by line:
	- Line 1: _1_ is assigned to variable _a_
	- Line 2: _0_ is assigned to variable _b_
	- Line 3: the result of the evaluation is _1_, so _a = 1_
	- Line 4: the result of the evaluation is also _1_, so _b = 1_
	- Line 5: the result of the evaluation _a = a ^ b_ (where _a = 1_ and _b = 1_) is _0_, so _a = 0_
	- the new values assigned to the _a_ and _b_ variables are then printed to the console.
</details>

---

13. What is the output of the following snippet?

```python
def fun(x):
    if x % 2 == 0:
        return 1
    else:
        return 2


print(fun(fun(2)))

```

- [ ] `2None`
- [ ] `1`
- [ ] the code will cause a runtime error
- [ ] `2`

<details>
  <summary>Answer</summary>

  - Answer: `2`
  - Reason: The _print()_ function in line 8 takes the _fun()_ function as its argument, which takes another _fun()_ function as its argument, which in turn takes the value _2_ as its argument.
	
	Let’s analyze the function calls, starting with the right-most ones:
	
	- the _fun(2)_ call – _x_ is assigned the value of _2_, so _x % 2 = 0_, so the comparison _0 == 0_ evaluates to True, and the function returns _1_, which is passed to the “left” _fun()_ function as its argument,
	- the _fun(1)_ call – _x_ is assigned the value of _1_, so _x % 2 = 1_, so the comparison _1 == 0_ evaluates to False, which means the function returns _2_, which is passed to the _print()_ function as its argument. Therefore, _2_ is printed to the screen.
</details>

---

14. Take a look at the snippet and choose the **true** statement:

```python
nums = [1, 2, 3]
vals = nums
del vals[:]

```

- [ ] the snippet will cause a runtime error
- [ ] `nums` and `vals` have the same length
- [ ] `vals` is longer than `nums`
- [ ] `nums` is longer than `vals`

<details>
  <summary>Answer</summary>

  - Answer: `nums` and `vals` have the same length
  - Reason: Assigning _nums_ to _vals_ creates a situation in which the same list (i.e. _[1, 2, 3]_) has two different names. Giving a new name to an existing list, in our case _vals_ to nums, is called **aliasing**. And since _nums_ and _vals_ are two different names that refer to the same object, they are also the same length.

	The _del_ instruction empties the list pointed to by _nums_ and _vals_, which means the list has a zero length, which in turn means that _nums_ and _vals_ are the same length.
</details>

---

15. What is the output of the following piece of code if the user enters two lines containing `3` and `2` respectively?

```python
x = int(input())
y = int(input())
x = x % y
x = x % y
y = y % x
print(y)

```

- [ ] `1`
- [ ] `2`
- [ ] `3`
- [ ] `0`

<details>
  <summary>Answer</summary>

  - Answer: `0`
  - Reason: Let’s analyze what happens:
	- _x = 3_ and _y = 2_
	- Line 3: _x = 3 % 2 = 1_
	- Line 4: _x = 1 % 2 = 1_
	- Line 5: _x = 2 % 1 = **0**_
	- the result is printed to the screen.
</details>

---

16. What is the output of the following piece of code if the user enters two lines containing `3` and `6` respectively?

```python
y = input()
x = input()
print(x + y)

```

- [ ] `36`
- [ ] `6`
- [ ] `3`
- [ ] `63`

<details>
  <summary>Answer</summary>

  - Answer: 
  - Reason: It’s a tricky question because of two reasons:
	- Reason one: the _input()_ function converts the data inputted by the user to a string, and the result of adding two strings to each other is gluing them together: _"string" + "string" = "stringstring"_ (concatenation).
	- Reason two: the first user input is assigned to the _y_ variable, while the second to the _x_variable. However, they are printed in the reverse order.
</details>

---

17. What is the output of the following piece of code?

`print("a", "b", "c", sep="sep")` 

- [ ] `asepbsepcsep`
- [ ] `a b c`
- [ ] `abc`
- [ ] `asepbsepc`

<details>
  <summary>Answer</summary>

  - Answer: `asepbsepc`
  - Reason: The _print()_ function prints the strings _"a"_, _"b"_, and _"c"_ to the screen, and separates them with the "sep" string. The _sep_ keyword parameter determines the type of separator used between the subsequent _print()_ arguments outputted to the screen.
</details>

---

18. What is the output of the following piece of code?

```python
x = 1 // 5 + 1 / 5
print(x)

```

- [ ] `0`
- [ ] `0.5`
- [ ] `0.4`
- [ ] `0.2`
<details>
  <summary>Answer</summary>

  - Answer: `0.2`
  - Reason: Remember the principle of Operator Precedence, and the difference between the two Python division operators: // (integer division) and _/_ (floating-point division). Let’s analyze the expression in the first line:

	Because the division operators have a higher priority than the addition operator, we can add brackets for readability, and evaluate the expression in the following way: _(1 // 5) + (1 / 5)_ gives _0 + 0.2_, which in turn evaluates to _0.2_.
</details>

---

19. Assuming that `my_tuple` is a correctly created tuple, the fact that tuples are immutable means that the following instruction:

`my_tuple[1] = my_tuple[1] + my_tuple[0]` 

- [ ] may be illegal if the tuple contains strings
- [ ] is illegal
- [ ] is fully correct
- [ ] can be executed if and only if the tuple contains at least two elements

<details>
  <summary>Answer</summary>

  - Answer: is illegal
  - Reason: Tuples are immutable sequences, which means you cannot update them directly – adding, changing, or removing tuple items requires different types of operations to be performed, for example converting the tuple to a list, updating the list, and converting it back to a tuple.
</details>

---

20. What is the output of the following piece of code if the user enters two lines containing `2` and `4` respectively?

```python
x = float(input())
y = float(input())
print(y ** (1 / x))

```

- [ ] `1.0`
- [ ] `0.0`
- [ ] `2.0`
- [ ] `4.2`

<details>
  <summary>Answer</summary>

  - Answer: `2.0`
  - Reason: Let’s analyze what happens:
	- the user enters _2_, which is converted to a float, and assigned to the _x_ variable
	- the user enters _4_, which is converted to a float, and assigned to the _y_ variable
	- the result of the following evaluation is printed to the screen: _4 ** (1 / 2) = 4 ** 0.5 = 2.0_
</details>